#!/usr/bin/env bash
set -euo pipefail

readonly VERSION="0.1.0"

readonly CONFIG_DIR_DEFAULT="$HOME/.worktree.sh"
readonly CONFIG_FILE_DEFAULT="$CONFIG_DIR_DEFAULT/config.json"

if [ -n "${WT_CONFIG_FILE:-}" ]; then
  readonly CONFIG_FILE="$WT_CONFIG_FILE"
else
  readonly CONFIG_FILE="$CONFIG_FILE_DEFAULT"
fi

if [ -n "${WT_CONFIG_CACHE_FILE:-}" ]; then
  readonly CONFIG_CACHE_FILE="$WT_CONFIG_CACHE_FILE"
else
  readonly CONFIG_CACHE_FILE="$CONFIG_FILE.cache"
fi

readonly CONFIG_DEFAULT_WORKING_REPO_PATH="${HOME}/Developer/your-project"
readonly CONFIG_DEFAULT_WORKTREE_ADD_BRANCH_PREFIX="feat/"
readonly CONFIG_DEFAULT_SERVE_DEV_LOGGING_PATH="tmp"
readonly CONFIG_DEFAULT_SERVE_DEV_ENABLED=1
readonly CONFIG_DEFAULT_INSTALL_DEPS_ENABLED=1
readonly CONFIG_DEFAULT_COPY_ENV_ENABLED=1
readonly CONFIG_DEFAULT_INSTALL_DEPS_COMMAND=""
readonly CONFIG_DEFAULT_SERVE_DEV_COMMAND=""
readonly CONFIG_DEFAULT_LANGUAGE="en"
readonly -a CONFIG_DEFAULT_COPY_ENV_FILES=(".env" ".env.local")

WORKING_REPO_PATH=""
WORKTREE_NAME_PREFIX=""
WORKTREE_BRANCH_PREFIX=""
SERVE_DEV_LOGGING_PATH=""
SERVE_DEV_ENABLED=0
INSTALL_DEPS_ENABLED=0
COPY_ENV_ENABLED=0
INSTALL_DEPS_COMMAND=""
SERVE_DEV_COMMAND=""
LANGUAGE="$CONFIG_DEFAULT_LANGUAGE"
WORKING_REPO_PATH_CONFIGURED=0
COPY_ENV_FILE_SELECTION=()

readonly SCRIPT_SOURCE="${BASH_SOURCE[0]:-${0}}"
script_dir_tmp=""
if script_dir_tmp=$(cd "$(dirname "$SCRIPT_SOURCE")" 2>/dev/null && pwd); then
  :
else
  script_dir_tmp=$(pwd)
fi
readonly SCRIPT_DIR="$script_dir_tmp"
readonly MESSAGES_FILE="$SCRIPT_DIR/messages.sh"
MESSAGES_LOADED=0

ensure_messages_loaded() {
  if [ "$MESSAGES_LOADED" = "1" ]; then
    return
  fi

  if [ -f "$MESSAGES_FILE" ]; then
    # shellcheck disable=SC1090
    . "$MESSAGES_FILE"
    MESSAGES_LOADED=1
    return
  fi

  printf 'wt: missing messages file (%s)\n' "$MESSAGES_FILE" >&2
  exit 1
}

normalize_language() {
  if [ $# -ne 1 ]; then
    return 1
  fi

  local raw
  raw=$(printf '%s' "$1" | tr '[:upper:]' '[:lower:]')
  raw=${raw%%.*}
  raw=${raw//-/_}

  case "$raw" in
    zh|zh_cn|zh_hans|zh_hant|zh_tw|cn|chinese|中文)
      printf 'zh\n'
      return 0
      ;;
    en|en_us|en_gb|english|英语)
      printf 'en\n'
      return 0
      ;;
  esac

  return 1
}

language_code_to_config_value() {
  case "${1:-}" in
    zh)
      printf 'zh\n'
      ;;
    en)
      printf 'en\n'
      ;;
    *)
      printf '%s\n' "${1:-}"
      ;;
  esac
}

init_language() {
  LANGUAGE="$CONFIG_DEFAULT_LANGUAGE"

  local value normalized from_config=0
  if value=$(config_get "language" 2>/dev/null); then
    if normalized=$(normalize_language "$value" 2>/dev/null); then
      LANGUAGE="$normalized"
      from_config=1
    fi
  fi

  value="${LANG:-}"
  if [ "$from_config" -eq 0 ] && [ -n "$value" ]; then
    if normalized=$(normalize_language "$value" 2>/dev/null); then
      LANGUAGE="$normalized"
    fi
  fi
}

detect_shell_type() {
  local shell_name="${SHELL##*/}"
  case "$shell_name" in
    bash)
      printf 'bash\n'
      ;;
    zsh)
      printf 'zsh\n'
      ;;
    *)
      printf 'none\n'
      ;;
  esac
}

msg() {
  ensure_messages_loaded
  local key
  key="${1:-}"
  shift || true
  case "$LANGUAGE" in
    zh)
      msg_zh "$key" "$@"
      ;;
    *)
      msg_en "$key" "$@"
      ;;
  esac
}



parse_bool() {
  if [ $# -ne 1 ]; then
    return 1
  fi
  local lower
  lower=$(printf '%s' "$1" | tr '[:upper:]' '[:lower:]')
  case "$lower" in
    1|true|yes|on)
      printf '1\n'
      ;;
    0|false|no|off)
      printf '0\n'
      ;;
    *)
      return 1
      ;;
  esac
}

CONFIG_PYTHON_BIN=""
readonly CONFIG_KV_DELIM=$'\x1f'

CONFIG_CACHE_LOADED=0
CONFIG_CACHE_KEYS=()
CONFIG_CACHE_TYPES=()
CONFIG_CACHE_VALUES=()
CONFIG_CACHE_ARRAY_KEYS=()
CONFIG_CACHE_ARRAY_VALUES=()

config_cache_reset() {
  CONFIG_CACHE_LOADED=0
  CONFIG_CACHE_KEYS=()
  CONFIG_CACHE_TYPES=()
  CONFIG_CACHE_VALUES=()
  CONFIG_CACHE_ARRAY_KEYS=()
  CONFIG_CACHE_ARRAY_VALUES=()
}

config_cache_array_append() {
  local array_key="$1"
  local array_value="$2"
  local idx

  for idx in "${!CONFIG_CACHE_ARRAY_KEYS[@]}"; do
    if [ "${CONFIG_CACHE_ARRAY_KEYS[$idx]}" = "$array_key" ]; then
      local existing="${CONFIG_CACHE_ARRAY_VALUES[$idx]-}"
      if [ -n "$existing" ]; then
        CONFIG_CACHE_ARRAY_VALUES["$idx"]=$(printf '%s\n%s' "$existing" "$array_value")
      else
        CONFIG_CACHE_ARRAY_VALUES["$idx"]="$array_value"
      fi
      return
    fi
  done

  CONFIG_CACHE_ARRAY_KEYS+=("$array_key")
  CONFIG_CACHE_ARRAY_VALUES+=("$array_value")
}

config_collect_entries() {
  if [ ! -f "$CONFIG_FILE" ] || [ ! -s "$CONFIG_FILE" ]; then
    if [ -n "${CONFIG_CACHE_FILE:-}" ]; then
      rm -f "$CONFIG_CACHE_FILE"
    fi
    return 0
  fi

  if [ -n "${CONFIG_CACHE_FILE:-}" ] && [ -f "$CONFIG_CACHE_FILE" ] && [ "$CONFIG_CACHE_FILE" -nt "$CONFIG_FILE" ]; then
    cat "$CONFIG_CACHE_FILE"
    return 0
  fi

  local python_bin
  python_bin=$(config_python_or_die)

  local -a python_cmd=("$python_bin" -S -B)

  local tmp
  tmp=$(mktemp "${TMPDIR:-/tmp}/wt-config-cache.XXXXXX") || return 1

  if ! "${python_cmd[@]}" - "$CONFIG_FILE" "$CONFIG_KV_DELIM" >"$tmp" <<'PY'; then
import json
import sys

def describe(value):
    if isinstance(value, bool):
        return "bool", "true" if value else "false"
    if isinstance(value, (int, float)) and not isinstance(value, bool):
        return "number", str(value)
    if value is None:
        return "null", "null"
    if isinstance(value, str):
        return "string", value
    return "json", json.dumps(value, ensure_ascii=False)

def walk(prefix, node):
    if isinstance(node, dict):
        for key in sorted(node):
            new_prefix = f"{prefix}.{key}" if prefix else key
            yield from walk(new_prefix, node[key])
    elif isinstance(node, list):
        yield prefix, "json", json.dumps(node, ensure_ascii=False)
        for item in node:
            _, item_repr = describe(item)
            yield prefix, "array", item_repr
    else:
        value_type, value_repr = describe(node)
        yield prefix, value_type, value_repr

def main(path, delim):
    with open(path, "r", encoding="utf-8") as fh:
        data = json.load(fh)

    for key, value_type, value_repr in walk("", data):
        sys.stdout.write(f"{key}{delim}{value_type}{delim}{value_repr}\n")

if __name__ == "__main__":
    main(sys.argv[1], sys.argv[2])
PY
    local status=$?
    rm -f "$tmp"
    return $status
  fi

  if [ -n "${CONFIG_CACHE_FILE:-}" ]; then
    local cache_dir
    cache_dir=$(dirname "$CONFIG_CACHE_FILE")
    if [ -n "$cache_dir" ]; then
      mkdir -p "$cache_dir" 2>/dev/null || true
    fi

    chmod 600 "$tmp" 2>/dev/null || true
    if mv "$tmp" "$CONFIG_CACHE_FILE" 2>/dev/null; then
      cat "$CONFIG_CACHE_FILE"
      return 0
    fi
  fi

  cat "$tmp"
  rm -f "$tmp"
  return 0
}


config_load_cache() {
  if [ "$CONFIG_CACHE_LOADED" = "1" ]; then
    return 0
  fi

  CONFIG_CACHE_KEYS=()
  CONFIG_CACHE_TYPES=()
  CONFIG_CACHE_VALUES=()

  local entries
  if ! entries=$(config_collect_entries); then
    return 1
  fi

  if [ -n "$entries" ]; then
    local entry_key entry_type entry_raw
    while IFS="$CONFIG_KV_DELIM" read -r entry_key entry_type entry_raw; do
      [ -n "$entry_key" ] || continue
      if [ "$entry_type" = "array" ]; then
        config_cache_array_append "$entry_key" "$entry_raw"
        continue
      fi
      CONFIG_CACHE_KEYS+=("$entry_key")
      CONFIG_CACHE_TYPES+=("$entry_type")
      CONFIG_CACHE_VALUES+=("$entry_raw")
    done <<EOF
$entries
EOF
  fi

  CONFIG_CACHE_LOADED=1
  return 0
}

config_python() {
  if [ -n "$CONFIG_PYTHON_BIN" ]; then
    printf '%s\n' "$CONFIG_PYTHON_BIN"
    return 0
  fi

  local candidate
  for candidate in python3 python; do
    if command -v "$candidate" >/dev/null 2>&1; then
      CONFIG_PYTHON_BIN="$candidate"
      printf '%s\n' "$CONFIG_PYTHON_BIN"
      return 0
    fi
  done

  return 1
}

config_python_or_die() {
  local bin
  if ! bin=$(config_python); then
    die "python3 (or python) is required for JSON configuration"
  fi
  printf '%s\n' "$bin"
}

config_get_entry() {
  local key="${1:-}"
  [ -n "$key" ] || return 1

  if ! config_load_cache; then
    return 1
  fi

  local idx
  for idx in "${!CONFIG_CACHE_KEYS[@]}"; do
    if [ "${CONFIG_CACHE_KEYS[$idx]}" = "$key" ]; then
      printf '%s%s%s\n' "${CONFIG_CACHE_TYPES[$idx]}" "$CONFIG_KV_DELIM" "${CONFIG_CACHE_VALUES[$idx]}"
      return 0
    fi
  done

  return 1
}

config_get() {
  local key="$1"
  local entry
  entry=$(config_get_entry "$key") || return 1
  printf '%s\n' "${entry#*"${CONFIG_KV_DELIM}"}"
}

config_get_array() {
  local key="$1"
  [ -f "$CONFIG_FILE" ] || return 1
  [ -s "$CONFIG_FILE" ] || return 0

  if ! config_load_cache; then
    return 1
  fi

  local idx
  for idx in "${!CONFIG_CACHE_ARRAY_KEYS[@]}"; do
    if [ "${CONFIG_CACHE_ARRAY_KEYS[$idx]}" = "$key" ]; then
      local items="${CONFIG_CACHE_ARRAY_VALUES[$idx]}"
      if [ -n "$items" ]; then
        printf '%s\n' "$items"
      fi
      return 0
    fi
  done

  return 0
}

config_set() {
  if [ $# -ne 2 ]; then
    die "$(msg config_set_requires)"
  fi

  local key="$1"
  local value="$2"
  local python_bin
  python_bin=$(config_python_or_die)

  local status
  local -a python_cmd=("$python_bin" -S -B)

  "${python_cmd[@]}" - "$CONFIG_FILE" "$key" "$value" <<'PY'
import json
import os
import sys

def parse_value(raw):
    try:
        return json.loads(raw)
    except json.JSONDecodeError:
        return raw

def ensure_parent(path):
    directory = os.path.dirname(path)
    if directory and not os.path.exists(directory):
        os.makedirs(directory, exist_ok=True)

def main(path, dotted_key, raw_value):
    ensure_parent(path)
    if os.path.exists(path):
        with open(path, "r", encoding="utf-8") as fh:
            try:
                data = json.load(fh)
            except json.JSONDecodeError as exc:
                print(f"failed to parse config JSON: {exc}", file=sys.stderr)
                return 2
    else:
        data = {}

    parts = [part for part in dotted_key.split('.') if part]
    if not parts:
        print("config key cannot be empty", file=sys.stderr)
        return 2

    cursor = data
    for part in parts[:-1]:
        if part not in cursor or not isinstance(cursor[part], dict):
            cursor[part] = {}
        cursor = cursor[part]

    cursor[parts[-1]] = parse_value(raw_value)

    with open(path, "w", encoding="utf-8") as fh:
        json.dump(data, fh, ensure_ascii=False, indent=2)
        fh.write("\n")

    return 0

if __name__ == "__main__":
    sys.exit(main(sys.argv[1], sys.argv[2], sys.argv[3]))
PY
  status=$?

  if [ $status -ne 0 ]; then
    die "$(msg config_update_failed)"
  fi

  chmod 600 "$CONFIG_FILE" 2>/dev/null || true
  if [ -n "${CONFIG_CACHE_FILE:-}" ]; then
    rm -f "$CONFIG_CACHE_FILE"
  fi
  config_cache_reset
}

config_unset() {
  if [ $# -ne 1 ]; then
    die "$(msg config_unset_requires)"
  fi

  local key="$1"
  [ -f "$CONFIG_FILE" ] || die "$(msg config_file_missing "$CONFIG_FILE")"

  local python_bin
  python_bin=$(config_python_or_die)

  local status
  local -a python_cmd=("$python_bin" -S -B)

  "${python_cmd[@]}" - "$CONFIG_FILE" "$key" <<'PY'
import json
import os
import sys

def main(path, dotted_key):
    if not os.path.exists(path):
        print("config file not found", file=sys.stderr)
        return 3

    with open(path, "r", encoding="utf-8") as fh:
        try:
            data = json.load(fh)
        except json.JSONDecodeError as exc:
            print(f"failed to parse config JSON: {exc}", file=sys.stderr)
            return 2

    parts = [part for part in dotted_key.split('.') if part]
    if not parts:
        print("config key cannot be empty", file=sys.stderr)
        return 2

    cursor = data
    lineage = [cursor]
    for part in parts[:-1]:
        if part in cursor and isinstance(cursor[part], dict):
            cursor = cursor[part]
            lineage.append(cursor)
        else:
            return 1

    if parts[-1] not in cursor:
        return 1

    del cursor[parts[-1]]

    # Prune empty dicts from bottom up
    def prune(path_parts, containers):
        for idx in range(len(path_parts) - 1, -1, -1):
            key = path_parts[idx]
            container = containers[idx]
            if isinstance(container.get(key), dict) and not container[key]:
                del container[key]

    prune(parts[:-1], lineage)

    with open(path, "w", encoding="utf-8") as fh:
        json.dump(data, fh, ensure_ascii=False, indent=2)
        fh.write("\n")

    return 0

if __name__ == "__main__":
    sys.exit(main(sys.argv[1], sys.argv[2]))
PY
  status=$?

  case "$status" in
    0)
      chmod 600 "$CONFIG_FILE" 2>/dev/null || true
      if [ -n "${CONFIG_CACHE_FILE:-}" ]; then
        rm -f "$CONFIG_CACHE_FILE"
      fi
      config_cache_reset
      ;;
    1)
      die "$(msg config_key_not_set "$key")"
      ;;
    2)
      die "$(msg config_update_failed)"
      ;;
    3)
      die "$(msg config_file_missing "$CONFIG_FILE")"
      ;;
    *)
      die "$(msg config_update_failed)"
      ;;
  esac
}

config_iterate_file() {
  config_collect_entries
}

json_escape_string() {
  local input="$1"
  input="${input//\\/\\\\}"
  input="${input//\"/\\\"}"
  input="${input//$'\n'/\\n}"
  input="${input//$'\r'/\\r}"
  input="${input//$'\t'/\\t}"
  printf '%s' "$input"
}

json_array_from_list() {
  if [ $# -eq 0 ]; then
    printf '[]\n'
    return
  fi

  local json="["
  local first=1
  local item escaped
  for item in "$@"; do
    escaped=$(json_escape_string "$item")
    if [ $first -eq 0 ]; then
      json+=", "
    fi
    json+="\"$escaped\""
    first=0
  done
  json+=']'
  printf '%s\n' "$json"
}

init_settings() {
  WORKING_REPO_PATH="$CONFIG_DEFAULT_WORKING_REPO_PATH"
  SERVE_DEV_LOGGING_PATH="$CONFIG_DEFAULT_SERVE_DEV_LOGGING_PATH"
  SERVE_DEV_ENABLED="$CONFIG_DEFAULT_SERVE_DEV_ENABLED"
  INSTALL_DEPS_ENABLED="$CONFIG_DEFAULT_INSTALL_DEPS_ENABLED"
  COPY_ENV_ENABLED="$CONFIG_DEFAULT_COPY_ENV_ENABLED"
  WORKTREE_BRANCH_PREFIX="$CONFIG_DEFAULT_WORKTREE_ADD_BRANCH_PREFIX"
  COPY_ENV_FILE_SELECTION=("${CONFIG_DEFAULT_COPY_ENV_FILES[@]}")
  INSTALL_DEPS_COMMAND="$CONFIG_DEFAULT_INSTALL_DEPS_COMMAND"
  SERVE_DEV_COMMAND="$CONFIG_DEFAULT_SERVE_DEV_COMMAND"
  WORKING_REPO_PATH_CONFIGURED=0

  WORKTREE_NAME_PREFIX="$(basename "$WORKING_REPO_PATH")."

  local entry type raw_value

  if entry=$(config_get_entry "workingRepo.path" 2>/dev/null); then
    type="${entry%%"${CONFIG_KV_DELIM}"*}"
    raw_value="${entry#*"${CONFIG_KV_DELIM}"}"
    if [ "$type" = "string" ] && [ -n "$raw_value" ]; then
      WORKING_REPO_PATH="$raw_value"
      WORKTREE_NAME_PREFIX="$(basename "$WORKING_REPO_PATH")."
      WORKING_REPO_PATH_CONFIGURED=1
    fi
  fi

  if entry=$(config_get_entry "worktreeAdd.serveDev.loggingPath" 2>/dev/null); then
    type="${entry%%"${CONFIG_KV_DELIM}"*}"
    raw_value="${entry#*"${CONFIG_KV_DELIM}"}"
    if [ "$type" = "string" ] && [ -n "$raw_value" ]; then
      SERVE_DEV_LOGGING_PATH="$raw_value"
    fi
  fi

  if entry=$(config_get_entry "worktreeAdd.serveDev.enabled" 2>/dev/null); then
    raw_value="${entry#*"${CONFIG_KV_DELIM}"}"
    if bool=$(parse_bool "$raw_value" 2>/dev/null); then
      SERVE_DEV_ENABLED="$bool"
    fi
  fi

  if entry=$(config_get_entry "worktreeAdd.installDeps.enabled" 2>/dev/null); then
    raw_value="${entry#*"${CONFIG_KV_DELIM}"}"
    if bool=$(parse_bool "$raw_value" 2>/dev/null); then
      INSTALL_DEPS_ENABLED="$bool"
    fi
  fi

  if entry=$(config_get_entry "worktreeAdd.copyEnv.enabled" 2>/dev/null); then
    raw_value="${entry#*"${CONFIG_KV_DELIM}"}"
    if bool=$(parse_bool "$raw_value" 2>/dev/null); then
      COPY_ENV_ENABLED="$bool"
    fi
  fi

  local -a copy_files=()
  while IFS= read -r copy_item; do
    copy_files+=("$copy_item")
  done < <(config_get_array "worktreeAdd.copyEnv.files" 2>/dev/null || true)

  if [ ${#copy_files[@]} -gt 0 ]; then
    COPY_ENV_FILE_SELECTION=("${copy_files[@]}")
  fi

  if entry=$(config_get_entry "worktreeAdd.branchPrefix" 2>/dev/null); then
    type="${entry%%"${CONFIG_KV_DELIM}"*}"
    raw_value="${entry#*"${CONFIG_KV_DELIM}"}"
    if [ "$type" = "string" ]; then
      WORKTREE_BRANCH_PREFIX="$raw_value"
    fi
  fi

  if entry=$(config_get_entry "worktreeAdd.installDeps.command" 2>/dev/null); then
    type="${entry%%"${CONFIG_KV_DELIM}"*}"
    raw_value="${entry#*"${CONFIG_KV_DELIM}"}"
    if [ "$type" = "string" ] && [ -n "$raw_value" ]; then
      INSTALL_DEPS_COMMAND="$raw_value"
    fi
  fi

  if entry=$(config_get_entry "worktreeAdd.serveDev.command" 2>/dev/null); then
    type="${entry%%"${CONFIG_KV_DELIM}"*}"
    raw_value="${entry#*"${CONFIG_KV_DELIM}"}"
    if [ "$type" = "string" ] && [ -n "$raw_value" ]; then
      SERVE_DEV_COMMAND="$raw_value"
    fi
  fi

  init_language
}

info() {
  printf '%s\n' "$*" >&2
}

die() {
  printf 'wt: %s\n' "$*" >&2
  exit 1
}

usage() {
  local project_dir_box_display="$WORKING_REPO_PATH"
  local project_dir_display="$WORKING_REPO_PATH"
  local dir_text_en
  local dir_text_zh
  local should_highlight=0

  if [ "$WORKING_REPO_PATH_CONFIGURED" -eq 1 ]; then
    dir_text_en="Project directory: ${project_dir_box_display}"
    dir_text_zh="项目目录: ${project_dir_box_display}"
    should_highlight=1
  else
    dir_text_en="Project directory: not set; run wt init inside your repo"
    dir_text_zh="项目目录: 未定义，请在仓库目录下运行 wt init"
  fi

  if [ "$should_highlight" -eq 1 ] && [ -t 1 ] && command -v tput >/dev/null 2>&1; then
    local ansi_cyan ansi_bold ansi_reset
    ansi_cyan=$(tput setaf 6 2>/dev/null || true)
    ansi_bold=$(tput bold 2>/dev/null || true)
    ansi_reset=$(tput sgr0 2>/dev/null || true)
    if [ -n "$ansi_cyan$ansi_bold" ]; then
      project_dir_display="${ansi_bold}${ansi_cyan}${project_dir_box_display}${ansi_reset}"
    fi
  fi

  local banner_width_en=${#dir_text_en}
  local banner_width_zh=${#dir_text_zh}

  if [ "$banner_width_en" -lt 40 ]; then
    banner_width_en=40
  fi
  if [ "$banner_width_zh" -lt 40 ]; then
    banner_width_zh=40
  fi

  local fill_en fill_zh
  fill_en=$(printf '%*s' "$banner_width_en" '')
  fill_en=${fill_en// /─}
  fill_zh=$(printf '%*s' "$banner_width_zh" '')
  fill_zh=${fill_zh// /─}

  local dir_top_en dir_mid_en dir_bottom_en dir_top_zh dir_mid_zh dir_bottom_zh
  dir_top_en="${fill_en}╮"
  dir_mid_en=$(printf '%-*s│' "$banner_width_en" "$dir_text_en")
  dir_bottom_en="${fill_en}╯"

  dir_top_zh="${fill_zh}╮"
  dir_mid_zh=$(printf '%-*s│' "$banner_width_zh" "$dir_text_zh")
  dir_bottom_zh="${fill_zh}╯"

  local dir_banner_en dir_banner_zh
  dir_banner_en=$(printf '%s\n%s\n%s' "$dir_top_en" "$dir_mid_en" "$dir_bottom_en")
  dir_banner_zh=$(printf '%s\n%s\n%s' "$dir_top_zh" "$dir_mid_zh" "$dir_bottom_zh")

  if [ "$should_highlight" -eq 1 ] && [ "$project_dir_display" != "$project_dir_box_display" ]; then
    dir_banner_en=${dir_banner_en//Project directory: $project_dir_box_display/Project directory: $project_dir_display}
    dir_banner_zh=${dir_banner_zh//项目目录: $project_dir_box_display/项目目录: $project_dir_display}
  fi

  case "$LANGUAGE" in
    zh)
      cat <<USAGE_ZH

用法:
  wt <command> [参数]        执行 wt 子命令
  wt <worktree-name>         直接跳转到对应 worktree

核心命令:
  init               将当前仓库设为 wt 的默认项目
  add <name>         创建新 worktree，复制环境文件、安装依赖并启动 dev server（可通过 wt config 调整）
  main               跳转到主 worktree
  list               列出所有 worktree
  rm [name]          删除 worktree（省略 name 时使用当前目录）
  clean              清理数字 worktree（匹配前缀 + 数字）
  config             查看或更新 worktree.sh 配置
  uninstall          卸载 wt 并清理 shell 集成
  help               显示此帮助

${dir_banner_zh}

USAGE_ZH
      ;;
    *)
      cat <<USAGE_EN

Usage:
  wt <command> [args]        Run a wt subcommand
  wt <worktree-name>         Jump straight to a worktree

Core commands:
  init               Remember this repository as wt's default project
  add <name>         Create a new worktree, copy env files, install deps, start dev server (tunable via wt config)
  main               Jump to the main worktree
  list               List all worktrees
  rm [name]          Remove a worktree (current directory if name omitted)
  clean              Remove numeric worktrees (matching prefix + digits)
  config             Inspect or update worktree.sh configuration
  uninstall          Uninstall wt and clean shell hooks
  help               Show this guide

${dir_banner_en}

USAGE_EN
      ;;
  esac
}

usage_exit() {
  local status="${1:-0}"
  usage
  exit "$status"
}

PROJECT_DIR=""
PROJECT_DIR_ABS=""
PROJECT_PARENT=""

resolve_project() {
  command -v git >/dev/null 2>&1 || die "$(msg git_required)"

  if [ -z "$PROJECT_DIR" ]; then
    if [ "$WORKING_REPO_PATH_CONFIGURED" -ne 1 ]; then
      die "$(msg project_dir_unset)"
    fi
    PROJECT_DIR="$WORKING_REPO_PATH"
  fi

  PROJECT_DIR_ABS=$(cd "$PROJECT_DIR" 2>/dev/null && pwd) || die "$(msg project_not_found "$PROJECT_DIR")"
  PROJECT_PARENT=$(dirname "$PROJECT_DIR_ABS")
}

worktree_path_for() {
  local name="$1"
  printf '%s/%s%s\n' "$PROJECT_PARENT" "$WORKTREE_NAME_PREFIX" "$name"
}

worktree_ref_exists() {
  local target="$1"
  local line

  while IFS= read -r line; do
    case "$line" in
      worktree\ *)
        local candidate="${line#worktree }"
        if [ "$candidate" = "$target" ]; then
          return 0
        fi
        ;;
    esac
  done < <(git_project worktree list --porcelain)

  return 1
}

branch_for() {
  local name="$1"
  printf '%s%s\n' "$WORKTREE_BRANCH_PREFIX" "$name"
}

port_from_name() {
  local name="$1"
  local digits=""

  if [[ "$name" =~ ^([0-9]+)$ ]]; then
    digits="${BASH_REMATCH[1]}"
  elif [[ "$name" =~ ([0-9]+)$ ]]; then
    digits="${BASH_REMATCH[1]}"
  fi

  if [ -n "$digits" ]; then
    if [ "$digits" -ge 1024 ] && [ "$digits" -le 65535 ]; then
      printf '%s\n' "$digits"
      return 0
    fi
  fi

  printf ''
}

git_project() {
  git -C "$PROJECT_DIR_ABS" "$@"
}

copy_env_file() {
  local file_name="$1"
  local target_dir="$2"
  if [ -f "$PROJECT_DIR_ABS/$file_name" ]; then
    cp "$PROJECT_DIR_ABS/$file_name" "$target_dir/"
    info "$(msg copy_env_file "$file_name")"
  fi
}

command_exists_for_line() {
  local line="$1"
  if [ -z "$line" ]; then
    return 1
  fi

  local -a tokens
  IFS=' ' read -r -a tokens <<<"$line"
  if [ ${#tokens[@]} -eq 0 ]; then
    return 1
  fi

  local token
  for token in "${tokens[@]}"; do
    if [[ "$token" == *=* ]]; then
      continue
    fi
    if command -v "$token" >/dev/null 2>&1; then
      return 0
    fi
    return 1
  done

  return 1
}

run_install_command() {
  local worktree_path="${1:?worktree path is required}"
  local command_line="${2:-}"

  if [ -z "$command_line" ]; then
    info "$(msg install_skipped_no_command)"
    return
  fi

  if ! command_exists_for_line "$command_line"; then
    info "$(msg command_not_found "$command_line")"
    return
  fi

  info "$(msg installing_dependencies "$command_line")"
  (
    cd "$worktree_path"
    sh -c "$command_line" >&2
  )
}

command_slug_from_line() {
  local line="$1"
  if [ -z "$line" ]; then
    printf 'dev'
    return
  fi

  local slug
  slug=$(printf '%s' "$line" | tr "[:space:]/\\" '_')
  slug=${slug//[^A-Za-z0-9._-]/_}
  slug=${slug#_}
  slug=${slug%%_}
  if [ -z "$slug" ]; then
    slug='dev'
  fi
  slug=${slug:0:40}
  printf '%s' "$slug"
}

infer_install_command() {
  local worktree_path="${1:?worktree path is required}"

  if [ -f "$worktree_path/pnpm-lock.yaml" ]; then
    printf 'pnpm install --frozen-lockfile\n'
    return 0
  fi

  if [ -f "$worktree_path/yarn.lock" ]; then
    printf 'yarn install --frozen-lockfile\n'
    return 0
  fi

  if [ -f "$worktree_path/bun.lockb" ]; then
    printf 'bun install\n'
    return 0
  fi

  if [ -f "$worktree_path/package.json" ]; then
    if [ -f "$worktree_path/package-lock.json" ] || [ -f "$worktree_path/npm-shrinkwrap.json" ]; then
      printf 'npm ci\n'
      return 0
    fi
    printf 'npm install\n'
    return 0
  fi

  if [ -f "$worktree_path/poetry.lock" ]; then
    printf 'poetry install\n'
    return 0
  fi

  if [ -f "$worktree_path/Pipfile" ]; then
    printf 'pipenv install\n'
    return 0
  fi

  if [ -f "$worktree_path/requirements.txt" ]; then
    printf 'pip install -r requirements.txt\n'
    return 0
  fi

  if [ -f "$worktree_path/pyproject.toml" ]; then
    printf 'pip install -e .\n'
    return 0
  fi

  return 1
}

infer_serve_command() {
  local worktree_path="${1:?worktree path is required}"

  if [ -f "$worktree_path/pnpm-lock.yaml" ] && has_package_json_script "$worktree_path" "dev"; then
    printf 'pnpm dev\n'
    return 0
  fi

  if [ -f "$worktree_path/yarn.lock" ] && has_package_json_script "$worktree_path" "dev"; then
    printf 'yarn dev\n'
    return 0
  fi

  if [ -f "$worktree_path/bun.lockb" ] && has_package_json_script "$worktree_path" "dev"; then
    printf 'bun dev\n'
    return 0
  fi

  if [ -f "$worktree_path/package.json" ]; then
    if has_package_json_script "$worktree_path" "dev"; then
      printf 'npm run dev\n'
      return 0
    fi
    if has_package_json_script "$worktree_path" "start"; then
      printf 'npm run start\n'
      return 0
    fi
  fi

  if [ -f "$worktree_path/manage.py" ]; then
    printf 'python manage.py runserver\n'
    return 0
  fi

  if [ -f "$worktree_path/pyproject.toml" ] && [ -f "$worktree_path/app.py" ]; then
    printf 'python app.py\n'
    return 0
  fi

  if [ -f "$worktree_path/app.py" ]; then
    printf 'python app.py\n'
    return 0
  fi

  return 1
}

has_package_json_script() {
  local project_dir="${1:?project directory is required}"
  local script_name="${2:?script name is required}"
  local package_json="$project_dir/package.json"

  [ -f "$package_json" ] || return 1

  if command -v node >/dev/null 2>&1; then
    if node - "$package_json" "$script_name" >/dev/null 2>&1 <<'NODE'
const fs = require('fs');
const [pkgPath, scriptName] = process.argv.slice(2);
try {
  const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8')) || {};
  if (pkg.scripts && pkg.scripts[scriptName]) {
    process.exit(0);
  }
} catch (err) {}
process.exit(1);
NODE
    then
      return 0
    fi
  fi

  local python=""
  for candidate in python3 python; do
    if command -v "$candidate" >/dev/null 2>&1; then
      python="$candidate"
      break
    fi
  done

  if [ -n "$python" ]; then
    if "$python" - "$package_json" "$script_name" >/dev/null 2>&1 <<'PY'
import json
import sys

pkg_path = sys.argv[1]
script_name = sys.argv[2]

try:
    with open(pkg_path, 'r', encoding='utf-8') as f:
        data = json.load(f)
    scripts = data.get('scripts') or {}
    if scripts.get(script_name):
        sys.exit(0)
except Exception:
    pass

sys.exit(1)
PY
    then
      return 0
    fi
  fi

  return 1
}

start_dev_server() {
  local worktree_path="${1:?worktree path is required}"
  local command_line="${2:-}"
  local port="${3:-}"

  if [ -z "$command_line" ]; then
    info "$(msg dev_skipped_no_command)"
    return
  fi

  if ! command_exists_for_line "$command_line"; then
    info "$(msg command_not_found "$command_line")"
    return
  fi

  mkdir -p "$worktree_path/$SERVE_DEV_LOGGING_PATH"
  local slug
  slug=$(command_slug_from_line "$command_line")

  local log_file
  if [ -n "$port" ]; then
    log_file="$worktree_path/$SERVE_DEV_LOGGING_PATH/${slug}-${port}.log"
  else
    log_file="$worktree_path/$SERVE_DEV_LOGGING_PATH/${slug}.log"
  fi
  local pid_file="${log_file}.pid"

  info "$(msg dev_command "$command_line")"
  if [ -n "$port" ]; then
    info "$(msg start_dev_port "$port")"
  else
    info "$(msg start_dev_generic)"
  fi

  (
    cd "$worktree_path"
    if [ -n "$port" ]; then
      nohup env PORT="$port" sh -c "$command_line" > "$log_file" 2>&1 &
    else
      nohup sh -c "$command_line" > "$log_file" 2>&1 &
    fi
    printf '%s\n' "$!" > "$pid_file"
  )

  local pid=""
  if [ -f "$pid_file" ]; then
    pid=$(cat "$pid_file" 2>/dev/null || true)
  fi

  sleep 1

  if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
    if [ -n "$port" ]; then
      info "$(msg dev_started_port "$port")"
    else
      info "$(msg dev_started_default)"
    fi
  else
    local pid_display="${pid:-unknown}"
    info "$(msg dev_failed "$pid_display" "$log_file")"
  fi

  info "$(msg dev_log_hint "$log_file")"
}

maybe_warn_shell_integration() {
  local target_path="${1:-}"

  if [ -n "${WT_SHELL_WRAPPED:-}" ]; then
    return
  fi

  if [ "${WT_SUPPRESS_AUTO_CD_HINT:-0}" = "1" ]; then
    return
  fi

  if [ ! -t 1 ]; then
    return
  fi

  if [ -z "$target_path" ] || [ ! -d "$target_path" ]; then
    return
  fi

  if [ "${WT_AUTO_CD_HINT_SHOWN:-0}" = "1" ]; then
    return
  fi

  WT_AUTO_CD_HINT_SHOWN=1

  local shell_name
  shell_name="${SHELL##*/}"
  if [ -z "$shell_name" ]; then
    shell_name="zsh"
  fi

  local hook_cmd="" rc_hint="reload your shell configuration" rc_file="" hook_present=0
  local hook_marker="# wt shell integration: auto-cd after wt add/path/main/remove/clean"

  case "$shell_name" in
    zsh)
      hook_cmd='wt shell-hook zsh >> ~/.zshrc'
      rc_hint='source ~/.zshrc'
      rc_file="$HOME/.zshrc"
      ;;
    bash)
      hook_cmd='wt shell-hook bash >> ~/.bashrc'
      rc_hint='source ~/.bashrc'
      rc_file="$HOME/.bashrc"
      ;;
    *)
      hook_cmd='wt shell-hook zsh >> ~/.zshrc'
      ;;
  esac

  if [ -n "$rc_file" ] && [ -f "$rc_file" ] && grep -Fq "$hook_marker" "$rc_file"; then
    hook_present=1
  fi

  if [ "$hook_present" -eq 1 ]; then
    info "$(msg auto_cd_pending "$rc_hint")"
    info "$(msg auto_cd_retry)"
    return
  fi

  info "$(msg auto_cd_disabled "$hook_cmd")"
  if [ "$rc_hint" = "reload your shell configuration" ]; then
    info "$(msg auto_cd_reload)"
  else
    info "$(msg auto_cd_execute "$rc_hint")"
  fi
}

cmd_list() {
  [ $# -eq 0 ] || die "$(msg list_no_args)"
  git_project worktree list
}

cmd_main() {
  [ $# -eq 0 ] || die "$(msg main_no_args)"
  maybe_warn_shell_integration "$PROJECT_DIR_ABS"
  printf '%s\n' "$PROJECT_DIR_ABS"
}

cmd_path() {
  if [ $# -ne 1 ]; then
    die "$(msg path_requires_name)"
  fi
  local name="$1"
  local target_path
  target_path=$(worktree_path_for "$name")
  if [ ! -d "$target_path" ]; then
    die "$(msg worktree_not_found "$name")"
  fi
  maybe_warn_shell_integration "$target_path"
  printf '%s\n' "$target_path"
}

cmd_add() {
  local name="$1"
  shift || true

  [ -n "$name" ] || die "$(msg add_requires_name)"

  local run_install="$INSTALL_DEPS_ENABLED"
  local run_dev="$SERVE_DEV_ENABLED"
  local copy_env="$COPY_ENV_ENABLED"
  local branch=""
  local numeric_name=""
  local effective_port=""

  if [[ "$name" =~ ^[0-9]+$ ]]; then
    numeric_name="$name"
    if [ "$numeric_name" -ge 1 ] && [ "$numeric_name" -lt 1024 ]; then
      info "$(msg reserved_port "$numeric_name")"
    elif [ "$numeric_name" -gt 65535 ]; then
      info "$(msg port_out_of_range "$numeric_name")"
    fi
  fi

  while [ $# -gt 0 ]; do
    case "$1" in
      -h|--help|help)
        usage
        exit 0
        ;;
      --)
        shift
        break
        ;;
      -*)
        die "$(msg add_unknown_option "$1")"
        ;;
      *)
        die "$(msg unexpected_extra_argument "$1")"
        ;;
    esac
    shift || true
  done

  if [ $# -gt 0 ]; then
    die "$(msg unexpected_extra_argument "$1")"
  fi

  if [ "$run_dev" -eq 1 ]; then
    effective_port=$(port_from_name "$name")

    if [ -z "$effective_port" ] && [ -n "$numeric_name" ]; then
      if [ "$numeric_name" -lt 1024 ]; then
        info "$(msg fallback_default_port)"
      elif [ "$numeric_name" -gt 65535 ]; then
        info "$(msg fallback_default_port)"
      fi
    fi
  fi

  local worktree_path
  worktree_path=$(worktree_path_for "$name")

  if [ -e "$worktree_path" ]; then
    die "$(msg worktree_exists "$worktree_path")"
  fi

  if [ -z "$branch" ]; then
    branch=$(branch_for "$name")
  fi

  info "$(msg creating_worktree "$worktree_path" "$branch")"
  git_project worktree add -b "$branch" "$worktree_path" >&2
  info "$(msg worktree_created)"

  if [ "$copy_env" -eq 1 ]; then
    if [ ${#COPY_ENV_FILE_SELECTION[@]} -gt 0 ]; then
      local env_file
      for env_file in "${COPY_ENV_FILE_SELECTION[@]}"; do
        [ -n "$env_file" ] || continue
        copy_env_file "$env_file" "$worktree_path"
      done
    fi
  fi

  local install_command="$INSTALL_DEPS_COMMAND"
  local serve_command="$SERVE_DEV_COMMAND"

  if [ "$run_install" -eq 1 ] && [ -z "$install_command" ]; then
    if install_command=$(infer_install_command "$worktree_path"); then
      info "$(msg install_detected "$install_command")"
    fi
  fi

  if [ "$run_dev" -eq 1 ] && [ -z "$serve_command" ]; then
    if serve_command=$(infer_serve_command "$worktree_path"); then
      info "$(msg serve_detected "$serve_command")"
    fi
  fi

  if [ "$run_install" -eq 1 ]; then
    run_install_command "$worktree_path" "$install_command"
  fi

  if [ "$run_dev" -eq 1 ]; then
    start_dev_server "$worktree_path" "$serve_command" "$effective_port"
  else
    info "$(msg dev_skipped_config)"
  fi

  info "$(msg worktree_ready "$worktree_path")"
  maybe_warn_shell_integration "$worktree_path"
  printf '%s\n' "$worktree_path"
}

config_print_effective() {
  printf 'language=%s\n' "$LANGUAGE"
  printf 'workingRepo.path=%s\n' "$WORKING_REPO_PATH"
  printf 'worktreeAdd.branchPrefix=%s\n' "$WORKTREE_BRANCH_PREFIX"

  local branch_value
  if branch_value=$(config_get "workingRepo.branch" 2>/dev/null); then
    if [ -n "$branch_value" ]; then
      printf 'workingRepo.branch=%s\n' "$branch_value"
    fi
  fi

  if [ "$COPY_ENV_ENABLED" -eq 1 ]; then
    printf 'worktreeAdd.copyEnv.enabled=true\n'
  else
    printf 'worktreeAdd.copyEnv.enabled=false\n'
  fi
  printf 'worktreeAdd.copyEnv.files=%s\n' "$(json_array_from_list "${COPY_ENV_FILE_SELECTION[@]}")"

  if [ "$INSTALL_DEPS_ENABLED" -eq 1 ]; then
    printf 'worktreeAdd.installDeps.enabled=true\n'
  else
    printf 'worktreeAdd.installDeps.enabled=false\n'
  fi
  printf 'worktreeAdd.installDeps.command=%s\n' "$INSTALL_DEPS_COMMAND"

  if [ "$SERVE_DEV_ENABLED" -eq 1 ]; then
    printf 'worktreeAdd.serveDev.enabled=true\n'
  else
    printf 'worktreeAdd.serveDev.enabled=false\n'
  fi
  printf 'worktreeAdd.serveDev.command=%s\n' "$SERVE_DEV_COMMAND"
  printf 'worktreeAdd.serveDev.loggingPath=%s\n' "$SERVE_DEV_LOGGING_PATH"

  while IFS="$CONFIG_KV_DELIM" read -r key type raw; do
    case "$key" in
      language|\
      workingRepo.path|\
      workingRepo.branch|\
      worktreeAdd.copyEnv.enabled|\
      worktreeAdd.copyEnv.files|\
      worktreeAdd.installDeps.enabled|\
      worktreeAdd.installDeps.command|\
      worktreeAdd.serveDev.enabled|\
      worktreeAdd.serveDev.command|\
      worktreeAdd.serveDev.loggingPath|\
      worktreeAdd.branchPrefix)
        continue
        ;;
    esac
    local value="$raw"
    printf '%s=%s\n' "$key" "$value"
  done < <(config_iterate_file)
}

config_usage() {
  case "$LANGUAGE" in
    zh)
      cat <<'CONFIG_USAGE_ZH'
wt config - 查看或更新 worktree.sh 配置

子命令:
  wt config list                 显示生效配置（包含默认值）
  wt config get <key>            输出指定配置项（若缺失则报错）
  wt config set <key> <value>    将配置写入 ~/.worktree.sh
  wt config unset <key>          从 ~/.worktree.sh 移除配置

快捷方式:
  wt config <key>                等同于 get
  wt config <key> <value>        等同于 set

支持的键:
  language                        CLI 显示语言（en|zh，默认 en）
  workingRepo.path                默认维护的仓库根目录（由 wt init 设置）
  workingRepo.branch              新 worktree 的默认分支（可选）
  worktreeAdd.branchPrefix        新 worktree 分支名前缀（默认 feat/）
  worktreeAdd.copyEnv.enabled     是否在 wt add 时复制环境文件
  worktreeAdd.copyEnv.files       被复制的环境文件列表（JSON 数组）
  worktreeAdd.installDeps.enabled 是否在 wt add 时安装依赖
  worktreeAdd.installDeps.command 安装依赖使用的命令（留空则自动推断）
  worktreeAdd.serveDev.enabled    是否在 wt add 后启动开发服务
  worktreeAdd.serveDev.command    启动开发服务的命令（留空则自动推断）
  worktreeAdd.serveDev.loggingPath Dev 服务日志所在子目录（默认: tmp）

说明:
  配置以 ~/.worktree.sh/config.json 为准，不再支持通过环境变量临时覆盖。
  布尔值接受 true/false/1/0/yes/no/on/off。
CONFIG_USAGE_ZH
      ;;
    *)
      cat <<'CONFIG_USAGE_EN'
wt config - Inspect or update worktree.sh configuration

Subcommands:
  wt config list                 Show effective configuration (includes defaults)
  wt config get <key>            Print a single value (fails if missing)
  wt config set <key> <value>    Persist value in ~/.worktree.sh
  wt config unset <key>          Remove key from ~/.worktree.sh

Shortcuts:
  wt config <key>                Shortcut for get
  wt config <key> <value>        Shortcut for set

Supported keys:
  language                        CLI language (en or zh; default: en)
  workingRepo.path                Root directory of the tracked repository (set by wt init)
  workingRepo.branch              Default branch for new worktrees (optional)
  worktreeAdd.branchPrefix        Branch name prefix used for new worktrees (default: feat/)
  worktreeAdd.copyEnv.enabled     Whether wt add copies environment files
  worktreeAdd.copyEnv.files       Environment files to copy (JSON array)
  worktreeAdd.installDeps.enabled Whether wt add installs dependencies
  worktreeAdd.installDeps.command Command used to install dependencies (empty = auto-detect)
  worktreeAdd.serveDev.enabled    Whether wt add starts the dev service
  worktreeAdd.serveDev.command    Command used to start the dev service (empty = auto-detect)
  worktreeAdd.serveDev.loggingPath Subdirectory for dev logs (default: tmp)

Notes:
  Runtime settings come solely from ~/.worktree.sh/config.json; environment overrides are ignored.
  Boolean values accept true/false/1/0/yes/no/on/off.
CONFIG_USAGE_EN
      ;;
  esac
}

cmd_config() {
  if [ $# -eq 0 ]; then
    config_usage
    return
  fi

  case "$1" in
    list|--list)
      if [ $# -ne 1 ]; then
        die "$(msg config_list_no_args)"
      fi
      init_settings
      config_print_effective
      ;;
    get|--get)
      shift || die "$(msg config_get_requires_key)"
      if [ $# -ne 1 ]; then
        die "$(msg config_get_requires_exactly_one)"
      fi
      local key="$1"
      local value
      if value=$(config_get "$key" 2>/dev/null); then
        printf '%s\n' "$value"
      else
        die "$(msg config_key_not_found "$key")"
      fi
      ;;
    set|--set)
      shift || die "$(msg config_set_requires)"
      if [ $# -ne 2 ]; then
        die "$(msg config_set_requires)"
      fi
      local key="$1"
      shift
      local value="$1"
      if [ "$key" = "language" ]; then
        if normalized=$(normalize_language "$value" 2>/dev/null); then
          value=$(language_code_to_config_value "$normalized")
        else
          die "$(msg invalid_language "$value")"
        fi
      fi
      config_set "$key" "$value"
      ;;
    unset|--unset)
      shift || die "$(msg config_unset_requires_key)"
      if [ $# -ne 1 ]; then
        die "$(msg config_unset_requires_exactly_one)"
      fi
      local key="$1"
      config_unset "$key"
      ;;
    -h|--help|help)
      config_usage
      ;;
    --*)
      die "$(msg config_unknown_option "$1")"
      ;;
    *)
      if [ $# -eq 1 ]; then
        local key="$1"
        local value
        if value=$(config_get "$key" 2>/dev/null); then
          printf '%s\n' "$value"
        else
          die "$(msg config_key_not_found "$key")"
        fi
      elif [ $# -eq 2 ]; then
        local key="$1"
        local value="$2"
        if [ "$key" = "language" ]; then
          if normalized=$(normalize_language "$value" 2>/dev/null); then
            value=$(language_code_to_config_value "$normalized")
          else
            die "$(msg invalid_language "$value")"
          fi
        fi
        config_set "$key" "$value"
      else
        die "$(msg config_expect_key_or_value)"
      fi
      ;;
  esac
}

cmd_shell_hook() {
  if [ $# -eq 0 ]; then
    die "$(msg shell_hook_requires_shell)"
  fi

  case "$1" in
    -h|--help|help)
      case "$LANGUAGE" in
        zh)
          cat <<'HOOK_USAGE_ZH'
wt shell-hook 用法:
  wt shell-hook zsh
  wt shell-hook bash

将输出通过 eval/source 加载以安装包装函数，例如：
  eval "$(wt shell-hook zsh)"
HOOK_USAGE_ZH
          ;;
        *)
          cat <<'HOOK_USAGE_EN'
wt shell-hook usage:
  wt shell-hook zsh
  wt shell-hook bash

Pipe the output into eval/source to install the wrapper, e.g.
  eval "$(wt shell-hook zsh)"
HOOK_USAGE_EN
          ;;
      esac
      return
      ;;
  esac

  local shell="$1"
  case "$shell" in
    zsh|bash)
      cat <<'WT_HOOK'
# wt shell integration: auto-cd after wt add/path/main/remove/clean
wt() {
  local __wt_out __wt_status __wt_cmd __wt_should_cd=0
  __wt_out="$(WT_SHELL_WRAPPED=1 command wt "$@")"
  __wt_status=$?

  if [ $__wt_status -ne 0 ]; then
    if [ -n "$__wt_out" ]; then
      printf '%s\n' "$__wt_out"
    fi
    return $__wt_status
  fi

  if [ $# -eq 0 ]; then
    __wt_cmd="list"
  else
    __wt_cmd="$1"
  fi

  case "$__wt_cmd" in
    add|main|path)
      __wt_should_cd=1
      ;;
    remove|rm|clean)
      __wt_should_cd=1
      ;;
    config|list|help|-h|--help|--version|version)
      __wt_should_cd=0
      ;;
    -*)
      __wt_should_cd=0
      ;;
    *)
      __wt_should_cd=1
      ;;
  esac

  if [ $__wt_should_cd -eq 1 ] && [ -n "$__wt_out" ] && [ -d "$__wt_out" ]; then
    cd "$__wt_out" || return $?
    return 0
  fi

  if [ -n "$__wt_out" ]; then
    printf '%s\n' "$__wt_out"
  fi
}
# wt shell integration: end
WT_HOOK
      ;;
    *)
      die "$(msg shell_hook_unsupported_shell "$shell")"
      ;;
  esac
}

uninstall_remove_shell_hook() {
  local shell_type="$1"
  local hook_file=""
  local hook_marker="# wt shell integration: auto-cd after wt add/path/main/remove/clean"
  local marker_end="# wt shell integration: end"

  case "$shell_type" in
    zsh)
      hook_file="$HOME/.zshrc"
      ;;
    bash)
      hook_file="$HOME/.bashrc"
      ;;
    *)
      info "$(msg uninstall_unknown_shell_type "$shell_type")"
      return 0
      ;;
  esac

  if [ ! -f "$hook_file" ]; then
    info "$(msg uninstall_shell_config_missing "$hook_file")"
    return 0
  fi

  if ! grep -Fq "$hook_marker" "$hook_file"; then
    info "$(msg uninstall_shell_hook_missing "$hook_file")"
    return 0
  fi

  local timestamp
  timestamp=$(date +%Y%m%d_%H%M%S)
  cp "$hook_file" "${hook_file}.backup.${timestamp}"
  info "$(msg uninstall_backup_created "$hook_file" "$timestamp")"

  local tmpfile
  tmpfile=$(mktemp) || die "$(msg temp_file_failed)"

  awk -v start="$hook_marker" -v finish="$marker_end" '
    BEGIN { mode=0 }
    {
      if (mode==0) {
        if ($0 == start) { mode=1; next }
        print
        next
      }

      if (mode==1) {
        if ($0 == finish) { mode=2; next }
        next
      }

      if (mode==2) {
        if ($0 ~ /^[[:space:]]*$/) { mode=0; next }
        mode=0
        print
        next
      }
    }
  ' "$hook_file" > "$tmpfile"

  mv "$tmpfile" "$hook_file"
  info "$(msg uninstall_shell_hook_removed "$hook_file")"
}

uninstall_backup_config() {
  local config_path="$CONFIG_FILE"
  local default_dir="$CONFIG_DIR_DEFAULT"
  local timestamp
  timestamp=$(date +%Y%m%d_%H%M%S)

  if [ "$config_path" = "$CONFIG_FILE_DEFAULT" ] && [ -d "$default_dir" ]; then
    local backup_path="${default_dir}.backup.${timestamp}"
    local candidate="$backup_path"
    local idx=1
    while [ -e "$candidate" ]; do
      candidate="${backup_path}.${idx}"
      idx=$((idx + 1))
    done
    mv "$default_dir" "$candidate"
    info "$(msg uninstall_config_backup_created "$default_dir" "$candidate")"
    return
  fi

  if [ -f "$config_path" ]; then
    local backup_path="${config_path}.backup.${timestamp}"
    local candidate="$backup_path"
    local idx=1
    while [ -e "$candidate" ]; do
      candidate="${backup_path}.${idx}"
      idx=$((idx + 1))
    done
    mv "$config_path" "$candidate"
    info "$(msg uninstall_config_backup_created "$config_path" "$candidate")"
  fi
}

cmd_uninstall() {
  local prefix="${WT_INSTALL_PREFIX:-$HOME/.local/bin}"
  local shell_type=""

  while [ $# -gt 0 ]; do
    case "$1" in
      --shell)
        shift || die "$(msg uninstall_requires_shell_value)"
        shell_type="$1"
        ;;
      --prefix)
        shift || die "$(msg uninstall_requires_prefix_value)"
        prefix="$1"
        ;;
      -h|--help|help)
        case "$LANGUAGE" in
          zh)
            cat <<'UNINSTALL_USAGE_ZH'
wt uninstall 用法:
  wt uninstall [--shell <shell>] [--prefix <dir>]

选项:
  --shell <shell>   指定要清理的 shell（zsh|bash|none；默认自动检测）
  --prefix <dir>    wt 安装目录（默认 $HOME/.local/bin）
  --help            查看帮助
UNINSTALL_USAGE_ZH
            ;;
          *)
            cat <<'UNINSTALL_USAGE_EN'
wt uninstall usage:
  wt uninstall [--shell <shell>] [--prefix <dir>]

Options:
  --shell <shell>   Shell to clean hooks for (zsh|bash|none; default: auto-detect)
  --prefix <dir>    Directory where wt is installed (default: $HOME/.local/bin)
  --help            Show this help
UNINSTALL_USAGE_EN
            ;;
        esac
        return
        ;;
      --)
        shift
        break
        ;;
      -*)
        die "$(msg uninstall_unknown_option "$1")"
        ;;
      *)
        die "$(msg uninstall_no_positional)"
        ;;
    esac
    shift || true
  done

  if [ $# -gt 0 ]; then
    die "$(msg uninstall_no_positional)"
  fi

  if [ -z "$shell_type" ]; then
    shell_type=$(detect_shell_type)
    info "$(msg uninstall_auto_detected_shell "$shell_type")"
  fi

  case "$shell_type" in
    zsh|bash|none) ;;
    *)
      die "$(msg uninstall_invalid_shell "$shell_type")"
      ;;
  esac

  local wt_bin="$prefix/wt"
  if [ -f "$wt_bin" ]; then
    rm -f "$wt_bin"
    info "$(msg uninstall_removed_binary "$wt_bin")"
  else
    info "$(msg uninstall_binary_missing "$wt_bin")"
  fi

  local messages_file="$prefix/messages.sh"
  if [ -f "$messages_file" ]; then
    rm -f "$messages_file"
    info "$(msg uninstall_removed_messages "$messages_file")"
  fi

  if [ "$shell_type" != "none" ]; then
    uninstall_remove_shell_hook "$shell_type"
  else
    info "$(msg uninstall_skip_shell_cleanup)"
  fi

  uninstall_backup_config

  info "$(msg uninstall_complete)"
  info "$(msg uninstall_worktrees_preserved)"
}

cmd_init() {
  local branch=""
  while [ $# -gt 0 ]; do
    case "$1" in
      --branch|branch)
        shift || die "$(msg branch_requires_value)"
        branch="$1"
        ;;
      --help|help)
        case "$LANGUAGE" in
          zh)
            cat <<'INIT_USAGE_ZH'
wt init 用法:
  wt init [branch <name>]

请在 franxx.store 仓库根目录运行，以将设置写入 ~/.worktree.sh：
- 设置 workingRepo.path 为仓库根目录。
- 提供 branch <name> 时设置 workingRepo.branch（默认使用当前分支）。
INIT_USAGE_ZH
            ;;
          *)
            cat <<'INIT_USAGE_EN'
wt init usage:
  wt init [branch <name>]

Run inside the franxx.store repository to capture settings into ~/.worktree.sh.
- Sets workingRepo.path to the repo root.
- Optionally sets workingRepo.branch when branch <name> is provided (defaults to current branch).
INIT_USAGE_EN
            ;;
        esac
        return
        ;;
      -*)
        die "$(msg init_unknown_option "$1")"
        ;;
      *)
        die "$(msg init_no_positional)"
        ;;
    esac
    shift || true
  done

  local repo_root repo_root_abs home_dir_abs
  repo_root=$(git rev-parse --show-toplevel 2>/dev/null) || die "$(msg init_run_inside_git)"
  if ! repo_root_abs=$(cd "$repo_root" 2>/dev/null && pwd -P); then
    repo_root_abs="$repo_root"
  fi
  if ! home_dir_abs=$(cd "$HOME" 2>/dev/null && pwd -P); then
    home_dir_abs="$HOME"
  fi

  if [ "$repo_root_abs" = "$home_dir_abs" ]; then
    die "$(msg init_forbid_home "$repo_root")"
  fi
  config_set "workingRepo.path" "$repo_root"
  info "$(msg init_set_project "$repo_root")"

  if [ -z "$branch" ]; then
    branch=$(git symbolic-ref --quiet --short HEAD 2>/dev/null || true)
  fi

  if [ -n "$branch" ]; then
    config_set "workingRepo.branch" "$branch"
    info "$(msg init_set_branch "$branch")"
  fi

  info "$(msg init_done)"
}

cmd_remove() {
  local name=""
  local assume_yes=0

  while [ $# -gt 0 ]; do
    case "$1" in
      -y|--yes|yes)
        assume_yes=1
        ;;
      -h|--help|help)
        usage
        exit 0
        ;;
      -*)
        die "$(msg remove_unknown_option "$1")"
        ;;
      *)
        if [ -n "$name" ]; then
          die "$(msg remove_accepts_at_most_one)"
        fi
        name="$1"
        ;;
    esac
    shift || true
  done

  local target_path=""
  local removing_current=0
  local current_abs
  current_abs=$(pwd -P)

  if [ -n "$name" ]; then
    target_path=$(worktree_path_for "$name")
    if [ ! -d "$target_path" ] && ! worktree_ref_exists "$target_path"; then
      die "$(msg worktree_not_found "$name")"
    fi
    if [ "$current_abs" = "$target_path" ]; then
      removing_current=1
    fi
  else
    if [ "$current_abs" = "$PROJECT_DIR_ABS" ]; then
      die "$(msg cannot_remove_main)"
    fi
    local current_base
    current_base=$(basename "$current_abs")
    if [[ "$current_base" != "$WORKTREE_NAME_PREFIX"* ]]; then
      die "$(msg specify_worktree_or_inside)"
    fi
    name="${current_base#"$WORKTREE_NAME_PREFIX"}"
    target_path="$current_abs"
    removing_current=1

    if [ "$assume_yes" -eq 0 ]; then
      printf '%s ' "$(msg remove_confirm_prompt "$name")" >&2
      read -r reply
      if [ -n "$reply" ] && [[ ! "$reply" =~ ^[Yy]$ ]]; then
        info "$(msg aborted)"
        return 1
      fi
    fi
  fi

  info "$(msg removing_worktree "$target_path")"
  local removal_succeeded=0
  if git_project worktree remove "$target_path" --force >&2; then
    removal_succeeded=1
  else
    if [ ! -d "$target_path" ]; then
      git_project worktree prune --expire now >&2 || true
      if ! worktree_ref_exists "$target_path"; then
        removal_succeeded=1
      fi
    fi
  fi

  if [ "$removal_succeeded" -eq 0 ]; then
    die "$(msg remove_failed)"
  fi

  local branch
  branch=$(branch_for "$name")
  if git_project show-ref --verify --quiet "refs/heads/$branch"; then
    git_project branch -D "$branch" >&2 || true
    info "$(msg removed_branch "$branch")"
  fi

  info "$(msg worktree_removed "$name")"

  if [ "$removing_current" -eq 1 ]; then
    info "$(msg current_worktree_removed)"
    maybe_warn_shell_integration "$PROJECT_DIR_ABS"
    printf '%s\n' "$PROJECT_DIR_ABS"
  fi
}

cmd_clean() {
  [ $# -eq 0 ] || die "$(msg clean_no_args)"
  local removed=0
  local current_abs
  current_abs=$(pwd -P)
  local current_removed=0

  while IFS= read -r worktree_path; do
    local base
    base=$(basename "$worktree_path")
    if [[ "$base" == "$WORKTREE_NAME_PREFIX"* ]]; then
      local suffix="${base#"$WORKTREE_NAME_PREFIX"}"
      if [[ "$suffix" =~ ^[0-9]+$ ]]; then
        info "$(msg cleaning_worktree "$suffix")"
        git_project worktree remove "$worktree_path" --force >&2 || true
        local branch_name
        branch_name=$(branch_for "$suffix")
        git_project branch -D "$branch_name" >/dev/null 2>&1 || true
        removed=$((removed + 1))
        if [ "$current_abs" = "$worktree_path" ]; then
          current_removed=1
        fi
      fi
    fi
  done < <(git_project worktree list --porcelain | awk '/^worktree / {print $2}')

  if [ "$removed" -gt 0 ]; then
    info "$(msg cleaned_count "$removed")"
  else
    info "$(msg cleaned_none)"
  fi

  if [ "$current_removed" -eq 1 ]; then
    info "$(msg clean_switch_back)"
    maybe_warn_shell_integration "$PROJECT_DIR_ABS"
    printf '%s\n' "$PROJECT_DIR_ABS"
  fi
}

main() {
  init_settings
  ensure_messages_loaded

  local command=""
  while [ $# -gt 0 ]; do
    case "$1" in
      --)
        shift
        break
        ;;
      -*)
        usage_exit 1
        ;;
      *)
        break
        ;;
    esac
    shift || true
  done

  if [ $# -eq 0 ]; then
    command="help"
  else
    command="$1"
    shift || true
  fi

  case "$command" in
    config)
      cmd_config "$@"
      return
      ;;
    shell-hook)
      cmd_shell_hook "$@"
      return
      ;;
    uninstall)
      cmd_uninstall "$@"
      return
      ;;
    init)
      cmd_init "$@"
      return
      ;;
    help)
      usage
      return
      ;;
    version)
      printf '%s\n' "$VERSION"
      return
      ;;
  esac

  resolve_project

  case "$command" in
    list)
      cmd_list "$@"
      ;;
    add)
      [ $# -ge 1 ] || die "$(msg add_requires_name)"
      cmd_add "$@"
      ;;
    rm|remove)
      cmd_remove "$@"
      ;;
    clean)
      cmd_clean "$@"
      ;;
    main)
      cmd_main "$@"
      ;;
    path)
      cmd_path "$@"
      ;;
    *)
      cmd_path "$command" "$@"
      ;;
  esac
}

main "$@"
