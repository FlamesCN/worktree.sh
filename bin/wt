#!/usr/bin/env bash
set -euo pipefail

readonly VERSION="0.2.0"

readonly CONFIG_DIR_DEFAULT="$HOME/.worktree.sh"
readonly CONFIG_FILE_DEFAULT="$CONFIG_DIR_DEFAULT/config.kv"

if [ -n "${WT_CONFIG_FILE:-}" ]; then
  readonly CONFIG_FILE="$WT_CONFIG_FILE"
else
  readonly CONFIG_FILE="$CONFIG_FILE_DEFAULT"
fi

readonly CONFIG_DEFAULT_WORKING_REPO_PATH="${HOME}/Developer/your-project"
readonly CONFIG_DEFAULT_WORKTREE_ADD_BRANCH_PREFIX="feat/"
readonly CONFIG_DEFAULT_SERVE_DEV_LOGGING_PATH="tmp"
readonly CONFIG_DEFAULT_SERVE_DEV_ENABLED=1
readonly CONFIG_DEFAULT_INSTALL_DEPS_ENABLED=1
readonly CONFIG_DEFAULT_COPY_ENV_ENABLED=1
readonly CONFIG_DEFAULT_INSTALL_DEPS_COMMAND=""
readonly CONFIG_DEFAULT_SERVE_DEV_COMMAND=""
readonly CONFIG_DEFAULT_LANGUAGE="en"
readonly -a CONFIG_DEFAULT_COPY_ENV_FILES=(".env" ".env.local")

readonly WT_UPDATE_WT_URL="https://raw.githubusercontent.com/notdp/worktree.sh/main/bin/wt"
readonly WT_UPDATE_MESSAGES_URL="https://raw.githubusercontent.com/notdp/worktree.sh/main/bin/messages.sh"
readonly WT_NPM_PACKAGE_NAME="worktree.sh"

WORKING_REPO_PATH=""
WORKTREE_NAME_PREFIX=""
WORKTREE_BRANCH_PREFIX=""
WORKING_REPO_BRANCH=""
SERVE_DEV_LOGGING_PATH=""
SERVE_DEV_ENABLED=0
INSTALL_DEPS_ENABLED=0
COPY_ENV_ENABLED=0
INSTALL_DEPS_COMMAND=""
SERVE_DEV_COMMAND=""
LANGUAGE="$CONFIG_DEFAULT_LANGUAGE"
WORKING_REPO_PATH_CONFIGURED=0
COPY_ENV_FILE_SELECTION=()

resolve_script_source() {
  if [ $# -ne 1 ]; then
    return 1
  fi

  local source="$1"
  while [ -L "$source" ]; do
    local dir target
    if ! dir=$(cd "$(dirname "$source")" 2>/dev/null && pwd); then
      break
    fi
    if ! target=$(readlink "$source"); then
      break
    fi
    if [ "${target#/}" = "$target" ]; then
      source="$dir/$target"
    else
      source="$target"
    fi
  done

  if [ "${source#/}" = "$source" ]; then
    local absolute_dir
    if absolute_dir=$(cd "$(dirname "$source")" 2>/dev/null && pwd); then
      printf '%s/%s\n' "$absolute_dir" "$(basename "$source")"
    else
      printf '%s\n' "$source"
    fi
  else
    printf '%s\n' "$source"
  fi
}

readonly SCRIPT_SOURCE_RAW="${BASH_SOURCE[0]:-${0}}"
readonly SCRIPT_SOURCE="$(resolve_script_source "$SCRIPT_SOURCE_RAW")"
script_dir_tmp=""
if script_dir_tmp=$(cd "$(dirname "$SCRIPT_SOURCE")" 2>/dev/null && pwd); then
  :
else
  script_dir_tmp=$(pwd)
fi
readonly SCRIPT_DIR="$script_dir_tmp"
readonly MESSAGES_FILE="$SCRIPT_DIR/messages.sh"
MESSAGES_LOADED=0
AUTO_CD_HINT_SHOWN=0

ensure_messages_loaded() {
  if [ "$MESSAGES_LOADED" = "1" ]; then
    return
  fi

  if [ -f "$MESSAGES_FILE" ]; then
    # shellcheck disable=SC1090
    . "$MESSAGES_FILE"
    MESSAGES_LOADED=1
    return
  fi

  printf 'wt: missing messages file (%s)\n' "$MESSAGES_FILE" >&2
  exit 1
}

normalize_language() {
  if [ $# -ne 1 ]; then
    return 1
  fi

  local raw
  raw=$(printf '%s' "$1" | tr '[:upper:]' '[:lower:]')
  raw=${raw%%.*}
  raw=${raw//-/_}

  case "$raw" in
    zh|zh_cn|zh_hans|zh_hant|zh_tw|cn|chinese|中文)
      printf 'zh\n'
      return 0
      ;;
    en|en_us|en_gb|english|英语)
      printf 'en\n'
      return 0
      ;;
  esac

  return 1
}

language_code_to_config_value() {
  case "${1:-}" in
    zh)
      printf 'zh\n'
      ;;
    en)
      printf 'en\n'
      ;;
    *)
      printf '%s\n' "${1:-}"
      ;;
  esac
}

init_language() {
  LANGUAGE="$CONFIG_DEFAULT_LANGUAGE"

  local value normalized from_config=0
  if value=$(config_get "language" 2>/dev/null); then
    if normalized=$(normalize_language "$value" 2>/dev/null); then
      LANGUAGE="$normalized"
      from_config=1
    fi
  fi

  value="${LANG:-}"
  if [ "$from_config" -eq 0 ] && [ -n "$value" ]; then
    if normalized=$(normalize_language "$value" 2>/dev/null); then
      LANGUAGE="$normalized"
    fi
  fi
}

detect_shell_type() {
  local shell_name="${SHELL##*/}"
  case "$shell_name" in
    bash)
      printf 'bash\n'
      ;;
    zsh)
      printf 'zsh\n'
      ;;
    *)
      printf 'none\n'
      ;;
  esac
}

msg() {
  ensure_messages_loaded
  local key
  key="${1:-}"
  shift || true
  case "$LANGUAGE" in
    zh)
      msg_zh "$key" "$@"
      ;;
    *)
      msg_en "$key" "$@"
      ;;
  esac
}



parse_bool() {
  if [ $# -ne 1 ]; then
    return 1
  fi
  local lower
  lower=$(printf '%s' "$1" | tr '[:upper:]' '[:lower:]')
  case "$lower" in
    1|true|yes|on)
      printf '1\n'
      ;;
    0|false|no|off)
      printf '0\n'
      ;;
    *)
      return 1
      ;;
  esac
}

CONFIG_CACHE_LOADED=0
CONFIG_CACHE_KEYS=()
CONFIG_CACHE_VALUES=()

config_cache_reset() {
  CONFIG_CACHE_LOADED=0
  CONFIG_CACHE_KEYS=()
  CONFIG_CACHE_VALUES=()
}



config_ensure_parent_dir() {
  if [ $# -ne 1 ]; then
    return 1
  fi
  local target="$1"
  local parent
  parent=$(dirname "$target")
  if [ -n "$parent" ] && [ ! -d "$parent" ]; then
    mkdir -p "$parent"
  fi
}

config_seed_defaults() {
  config_ensure_parent_dir "$CONFIG_FILE" || return 1

  local tmp
  tmp=$(mktemp "${TMPDIR:-/tmp}/wt-config-defaults.XXXXXX") || return 1

  {
    printf 'language=%s\n' "$CONFIG_DEFAULT_LANGUAGE"
    printf 'repo.path=%s\n' "$CONFIG_DEFAULT_WORKING_REPO_PATH"
    printf 'repo.branch=\n'
    printf 'add.branch-prefix=%s\n' "$CONFIG_DEFAULT_WORKTREE_ADD_BRANCH_PREFIX"
    printf 'add.copy-env.enabled=%s\n' "$(config_bool_to_string "$CONFIG_DEFAULT_COPY_ENV_ENABLED")"
    printf 'add.copy-env.files=%s\n' "$(json_array_from_list "${CONFIG_DEFAULT_COPY_ENV_FILES[@]}")"
    printf 'add.install-deps.enabled=%s\n' "$(config_bool_to_string "$CONFIG_DEFAULT_INSTALL_DEPS_ENABLED")"
    printf 'add.install-deps.command=%s\n' "$CONFIG_DEFAULT_INSTALL_DEPS_COMMAND"
    printf 'add.serve-dev.enabled=%s\n' "$(config_bool_to_string "$CONFIG_DEFAULT_SERVE_DEV_ENABLED")"
    printf 'add.serve-dev.command=%s\n' "$CONFIG_DEFAULT_SERVE_DEV_COMMAND"
    printf 'add.serve-dev.logging-path=%s\n' "$CONFIG_DEFAULT_SERVE_DEV_LOGGING_PATH"
  } >"$tmp"

  if mv "$tmp" "$CONFIG_FILE"; then
    chmod 600 "$CONFIG_FILE" 2>/dev/null || true
    return 0
  fi

  rm -f "$tmp"
  return 1
}

config_ensure_seeded() {
  if [ -f "$CONFIG_FILE" ] && [ -s "$CONFIG_FILE" ]; then
    return 0
  fi

  config_seed_defaults
}

config_cache_load() {
  if [ "$CONFIG_CACHE_LOADED" = "1" ]; then
    return 0
  fi

  if ! config_ensure_seeded; then
    return 1
  fi

  CONFIG_CACHE_KEYS=()
  CONFIG_CACHE_VALUES=()

  if [ ! -f "$CONFIG_FILE" ]; then
    CONFIG_CACHE_LOADED=1
    return 0
  fi

  local line key value
  while IFS= read -r line || [ -n "$line" ]; do
    case "$line" in
      ''|'#'*)
        continue
        ;;
    esac
    if [[ "$line" != *"="* ]]; then
      continue
    fi
    key="${line%%=*}"
    value="${line#*=}"
    [ -n "$key" ] || continue
    CONFIG_CACHE_KEYS+=("$key")
    CONFIG_CACHE_VALUES+=("$value")
  done <"$CONFIG_FILE"

  CONFIG_CACHE_LOADED=1
  return 0
}

config_get() {
  local key="${1:-}"
  [ -n "$key" ] || return 1

  if ! config_cache_load; then
    return 1
  fi

  local idx
  for idx in "${!CONFIG_CACHE_KEYS[@]}"; do
    if [ "${CONFIG_CACHE_KEYS[$idx]}" = "$key" ]; then
      printf '%s\n' "${CONFIG_CACHE_VALUES[$idx]}"
      return 0
    fi
  done

  return 1
}

config_default_value() {
  if [ $# -ne 1 ]; then
    return 1
  fi

  local key="$1"
  case "$key" in
    language)
      printf '%s\n' "$CONFIG_DEFAULT_LANGUAGE"
      ;;
    repo.path)
      printf '%s\n' "$CONFIG_DEFAULT_WORKING_REPO_PATH"
      ;;
    repo.branch)
      printf '\n'
      ;;
    add.branch-prefix)
      printf '%s\n' "$CONFIG_DEFAULT_WORKTREE_ADD_BRANCH_PREFIX"
      ;;
    add.copy-env.enabled)
      config_bool_to_string "$CONFIG_DEFAULT_COPY_ENV_ENABLED"
      ;;
    add.copy-env.files)
      json_array_from_list "${CONFIG_DEFAULT_COPY_ENV_FILES[@]}"
      ;;
    add.install-deps.enabled)
      config_bool_to_string "$CONFIG_DEFAULT_INSTALL_DEPS_ENABLED"
      ;;
    add.install-deps.command)
      printf '%s\n' "$CONFIG_DEFAULT_INSTALL_DEPS_COMMAND"
      ;;
    add.serve-dev.enabled)
      config_bool_to_string "$CONFIG_DEFAULT_SERVE_DEV_ENABLED"
      ;;
    add.serve-dev.command)
      printf '%s\n' "$CONFIG_DEFAULT_SERVE_DEV_COMMAND"
      ;;
    add.serve-dev.logging-path)
      printf '%s\n' "$CONFIG_DEFAULT_SERVE_DEV_LOGGING_PATH"
      ;;
    *)
      return 1
      ;;
  esac
}

config_get_or_default() {
  if [ $# -ne 1 ]; then
    return 1
  fi

  local key="$1"
  local value

  if value=$(config_get "$key" 2>/dev/null); then
    printf '%s\n' "$value"
    return 0
  fi

  if value=$(config_default_value "$key" 2>/dev/null); then
    printf '%s\n' "$value"
    return 0
  fi

  return 1
}


config_set() {
  if [ $# -ne 2 ]; then
    die "$(msg config_set_requires)"
  fi

  local key="$1"
  local value="$2"

  if ! config_ensure_seeded; then
    die "$(msg config_update_failed)"
  fi

  local tmp
  tmp=$(mktemp "${TMPDIR:-/tmp}/wt-config.XXXXXX") || die "$(msg config_update_failed)"

  local updated=0
  local line current_key
  if [ -f "$CONFIG_FILE" ]; then
    while IFS= read -r line || [ -n "$line" ]; do
      if [[ "$line" != *"="* ]]; then
        printf '%s\n' "$line" >>"$tmp"
        continue
      fi

      current_key="${line%%=*}"
      if [ -z "$current_key" ]; then
        continue
      fi

      if [ "$current_key" = "$key" ]; then
        printf '%s=%s\n' "$key" "$value" >>"$tmp"
        updated=1
      else
        printf '%s\n' "$line" >>"$tmp"
      fi
    done <"$CONFIG_FILE"
  fi

  if [ "$updated" -eq 0 ]; then
    printf '%s=%s\n' "$key" "$value" >>"$tmp"
  fi

  if mv "$tmp" "$CONFIG_FILE"; then
    chmod 600 "$CONFIG_FILE" 2>/dev/null || true
    config_cache_reset
    return 0
  fi

  rm -f "$tmp"
  die "$(msg config_update_failed)"
}

config_unset() {
  if [ $# -ne 1 ]; then
    die "$(msg config_unset_requires)"
  fi

  local key="$1"

  if ! config_ensure_seeded; then
    die "$(msg config_file_missing "$CONFIG_FILE")"
  fi

  if [ ! -f "$CONFIG_FILE" ]; then
    die "$(msg config_file_missing "$CONFIG_FILE")"
  fi

  local default_value=""
  local has_default=0
  if default_value=$(config_default_value "$key" 2>/dev/null); then
    has_default=1
  fi

  local tmp
  tmp=$(mktemp "${TMPDIR:-/tmp}/wt-config.XXXXXX") || die "$(msg config_update_failed)"

  local found=0
  local line current_key
  while IFS= read -r line || [ -n "$line" ]; do
    if [[ "$line" != *"="* ]]; then
      printf '%s\n' "$line" >>"$tmp"
      continue
    fi

    current_key="${line%%=*}"
    if [ -z "$current_key" ]; then
      continue
    fi

    if [ "$current_key" = "$key" ]; then
      found=1
      if [ "$has_default" -eq 1 ]; then
        printf '%s=%s\n' "$key" "$default_value" >>"$tmp"
      fi
    else
      printf '%s\n' "$line" >>"$tmp"
    fi
  done <"$CONFIG_FILE"

  if [ "$found" -eq 0 ]; then
    if [ "$has_default" -eq 1 ]; then
      printf '%s=%s\n' "$key" "$default_value" >>"$tmp"
    else
      rm -f "$tmp"
      die "$(msg config_key_not_set "$key")"
    fi
  fi

  if mv "$tmp" "$CONFIG_FILE"; then
    chmod 600 "$CONFIG_FILE" 2>/dev/null || true
    config_cache_reset
    return 0
  fi

  rm -f "$tmp"
  die "$(msg config_update_failed)"
}

json_escape_string() {
  local input="$1"
  input="${input//\\/\\\\}"
  input="${input//\"/\\\"}"
  input="${input//$'\n'/\\n}"
  input="${input//$'\r'/\\r}"
  input="${input//$'\t'/\\t}"
  printf '%s' "$input"
}

json_array_from_list() {
  if [ $# -eq 0 ]; then
    printf '[]\n'
    return
  fi

  local json="["
  local first=1
  local item escaped
  for item in "$@"; do
    escaped=$(json_escape_string "$item")
    if [ $first -eq 0 ]; then
      json+=", "
    fi
    json+="\"$escaped\""
    first=0
  done
  json+=']'
  printf '%s\n' "$json"
}

init_settings() {
  if init_settings_from_file 2>/dev/null; then
    return
  fi

  init_settings_defaults
}

init_settings_from_file() {
  WORKING_REPO_PATH="$CONFIG_DEFAULT_WORKING_REPO_PATH"
  SERVE_DEV_LOGGING_PATH="$CONFIG_DEFAULT_SERVE_DEV_LOGGING_PATH"
  SERVE_DEV_ENABLED="$CONFIG_DEFAULT_SERVE_DEV_ENABLED"
  INSTALL_DEPS_ENABLED="$CONFIG_DEFAULT_INSTALL_DEPS_ENABLED"
  COPY_ENV_ENABLED="$CONFIG_DEFAULT_COPY_ENV_ENABLED"
  WORKTREE_BRANCH_PREFIX="$CONFIG_DEFAULT_WORKTREE_ADD_BRANCH_PREFIX"
  WORKING_REPO_BRANCH=""
  COPY_ENV_FILE_SELECTION=("${CONFIG_DEFAULT_COPY_ENV_FILES[@]}")
  INSTALL_DEPS_COMMAND="$CONFIG_DEFAULT_INSTALL_DEPS_COMMAND"
  SERVE_DEV_COMMAND="$CONFIG_DEFAULT_SERVE_DEV_COMMAND"
  WORKING_REPO_PATH_CONFIGURED=0
  LANGUAGE="$CONFIG_DEFAULT_LANGUAGE"

  if ! config_ensure_seeded; then
    return 1
  fi

  [ -f "$CONFIG_FILE" ] || return 1

  local key value
  while IFS='=' read -r key value; do
    [ -n "$key" ] || continue
    case "$key" in
      language)
        [ -n "$value" ] && LANGUAGE="$value"
        ;;
      repo.path)
        if [ -n "$value" ] && [ "$value" != "$CONFIG_DEFAULT_WORKING_REPO_PATH" ]; then
          WORKING_REPO_PATH="$value"
          WORKTREE_NAME_PREFIX="$(basename "$WORKING_REPO_PATH")."
          WORKING_REPO_PATH_CONFIGURED=1
        fi
        ;;
      repo.branch)
        WORKING_REPO_BRANCH="$value"
        ;;
      add.branch-prefix)
        [ -n "$value" ] && WORKTREE_BRANCH_PREFIX="$value"
        ;;
      add.serve-dev.logging-path)
        [ -n "$value" ] && SERVE_DEV_LOGGING_PATH="$value"
        ;;
      add.serve-dev.enabled)
        if bool_val=$(parse_bool "$value" 2>/dev/null); then
          SERVE_DEV_ENABLED="$bool_val"
        fi
        ;;
      add.serve-dev.command)
        SERVE_DEV_COMMAND="$value"
        ;;
      add.install-deps.enabled)
        if bool_val=$(parse_bool "$value" 2>/dev/null); then
          INSTALL_DEPS_ENABLED="$bool_val"
        fi
        ;;
      add.install-deps.command)
        INSTALL_DEPS_COMMAND="$value"
        ;;
      add.copy-env.enabled)
        if bool_val=$(parse_bool "$value" 2>/dev/null); then
          COPY_ENV_ENABLED="$bool_val"
        fi
        ;;
      add.copy-env.files)
        if [ -n "$value" ] && [[ "$value" =~ ^\[.*\]$ ]]; then
          local trimmed="${value#[}"
          trimmed="${trimmed%]}"
          local -a files=()
          if [ -n "$trimmed" ]; then
            local -a raw_items=()
            IFS=',' read -r -a raw_items <<< "$trimmed"
            local item=""
            for item in "${raw_items[@]}"; do
              item="${item#"${item%%[![:space:]]*}"}"
              item="${item%"${item##*[![:space:]]}"}"
              item="${item#\"}"
              item="${item%\"}"
              [ -n "$item" ] && files+=("$item")
            done
          fi
          if [ ${#files[@]} -gt 0 ]; then
            COPY_ENV_FILE_SELECTION=("${files[@]}")
          fi
        fi
        ;;
    esac
  done < "$CONFIG_FILE"

  WORKTREE_NAME_PREFIX="$(basename "$WORKING_REPO_PATH")."
  init_language
  return 0
}

init_settings_defaults() {
  WORKING_REPO_PATH="$CONFIG_DEFAULT_WORKING_REPO_PATH"
  SERVE_DEV_LOGGING_PATH="$CONFIG_DEFAULT_SERVE_DEV_LOGGING_PATH"
  SERVE_DEV_ENABLED="$CONFIG_DEFAULT_SERVE_DEV_ENABLED"
  INSTALL_DEPS_ENABLED="$CONFIG_DEFAULT_INSTALL_DEPS_ENABLED"
  COPY_ENV_ENABLED="$CONFIG_DEFAULT_COPY_ENV_ENABLED"
  WORKTREE_BRANCH_PREFIX="$CONFIG_DEFAULT_WORKTREE_ADD_BRANCH_PREFIX"
  WORKING_REPO_BRANCH=""
  COPY_ENV_FILE_SELECTION=("${CONFIG_DEFAULT_COPY_ENV_FILES[@]}")
  INSTALL_DEPS_COMMAND="$CONFIG_DEFAULT_INSTALL_DEPS_COMMAND"
  SERVE_DEV_COMMAND="$CONFIG_DEFAULT_SERVE_DEV_COMMAND"
  WORKING_REPO_PATH_CONFIGURED=0
  LANGUAGE="$CONFIG_DEFAULT_LANGUAGE"

  WORKTREE_NAME_PREFIX="$(basename "$CONFIG_DEFAULT_WORKING_REPO_PATH")."

  init_language
}

config_bool_to_string() {
  if [ "$1" -eq 1 ]; then
    printf 'true\n'
  else
    printf 'false\n'
  fi
}

info() {
  printf '%s\n' "$*" >&2
}

die() {
  printf 'wt: %s\n' "$*" >&2
  exit 1
}

usage() {
  local project_dir_box_display="$WORKING_REPO_PATH"
  local project_dir_display="$WORKING_REPO_PATH"
  local dir_text_en
  local dir_text_zh
  local should_highlight=0

  if [ "$WORKING_REPO_PATH_CONFIGURED" -eq 1 ]; then
    dir_text_en="Project directory: ${project_dir_box_display}"
    dir_text_zh="${dir_text_en}"
    should_highlight=1
  else
    dir_text_en="Project directory: not set; run wt init inside your repo"
    dir_text_zh="${dir_text_en}"
  fi

  if [ "$should_highlight" -eq 1 ] && [ -t 1 ] && command -v tput >/dev/null 2>&1; then
    local ansi_cyan ansi_bold ansi_reset
    ansi_cyan=$(tput setaf 6 2>/dev/null || true)
    ansi_bold=$(tput bold 2>/dev/null || true)
    ansi_reset=$(tput sgr0 2>/dev/null || true)
    if [ -n "$ansi_cyan$ansi_bold" ]; then
      project_dir_display="${ansi_bold}${ansi_cyan}${project_dir_box_display}${ansi_reset}"
    fi
  fi

  local banner_width_en=${#dir_text_en}
  local banner_width_zh=${#dir_text_zh}

  if [ "$banner_width_en" -lt 40 ]; then
    banner_width_en=40
  fi
  if [ "$banner_width_zh" -lt 40 ]; then
    banner_width_zh=40
  fi

  local fill_en fill_zh
  fill_en=$(printf '%*s' "$banner_width_en" '')
  fill_en=${fill_en// /─}
  fill_zh=$(printf '%*s' "$banner_width_zh" '')
  fill_zh=${fill_zh// /─}

  local dir_top_en dir_mid_en dir_bottom_en dir_top_zh dir_mid_zh dir_bottom_zh
  dir_top_en="${fill_en}╮"
  dir_mid_en=$(printf '%-*s│' "$banner_width_en" "$dir_text_en")
  dir_bottom_en="${fill_en}╯"

  dir_top_zh="${fill_zh}╮"
  dir_mid_zh=$(printf '%-*s│' "$banner_width_zh" "$dir_text_zh")
  dir_bottom_zh="${fill_zh}╯"

  local dir_banner_en dir_banner_zh
  dir_banner_en=$(printf '%s\n%s\n%s' "$dir_top_en" "$dir_mid_en" "$dir_bottom_en")
  dir_banner_zh=$(printf '%s\n%s\n%s' "$dir_top_zh" "$dir_mid_zh" "$dir_bottom_zh")

  if [ "$should_highlight" -eq 1 ] && [ "$project_dir_display" != "$project_dir_box_display" ]; then
    dir_banner_en=${dir_banner_en//Project directory: $project_dir_box_display/Project directory: $project_dir_display}
    dir_banner_zh=${dir_banner_zh//Project directory: $project_dir_box_display/Project directory: $project_dir_display}
  fi

  case "$LANGUAGE" in
    zh)
      cat <<USAGE_ZH

用法:
  wt <command> [参数]        执行 wt 子命令
  wt <worktree-name>         直接跳转到对应 worktree

核心命令:
  init               将当前仓库设为 wt 的默认项目
  add <name>         创建新 worktree，复制环境文件、安装依赖并启动 dev server（可通过 wt config 调整）
  main               跳转到主 worktree
  list               列出所有 worktree
  rm [name ...]      删除一个或多个 worktree（省略 name 时使用当前目录）
  clean              清理数字 worktree（匹配前缀 + 数字）
  config             查看或更新 worktree.sh 配置
  uninstall          卸载 wt 并清理 shell 集成
  update             下载最新版 wt 脚本和消息文件（需要 curl）
  help               显示此帮助

${dir_banner_zh}

USAGE_ZH
      ;;
    *)
      cat <<USAGE_EN

Usage:
  wt <command> [args]        Run a wt subcommand
  wt <worktree-name>         Jump straight to a worktree

Core commands:
  init               Remember this repository as wt's default project
  add <name>         Create a new worktree, copy env files, install deps, start dev server (tunable via wt config)
  main               Jump to the main worktree
  list               List all worktrees
  rm [name ...]      Remove one or more worktrees (current directory if name omitted)
  clean              Remove numeric worktrees (matching prefix + digits)
  config             Inspect or update worktree.sh configuration
  uninstall          Uninstall wt and clean shell hooks
  update             Download the latest wt script and messages (requires curl)
  help               Show this guide

${dir_banner_en}

USAGE_EN
      ;;
  esac
}

usage_exit() {
  local status="${1:-0}"
  usage
  exit "$status"
}

PROJECT_DIR=""
PROJECT_DIR_ABS=""
PROJECT_PARENT=""

resolve_project() {
  command -v git >/dev/null 2>&1 || die "$(msg git_required)"

  if [ -z "$PROJECT_DIR" ]; then
    if [ "$WORKING_REPO_PATH_CONFIGURED" -ne 1 ]; then
      die "$(msg project_dir_unset)"
    fi
    PROJECT_DIR="$WORKING_REPO_PATH"
  fi

  PROJECT_DIR_ABS=$(cd "$PROJECT_DIR" 2>/dev/null && pwd) || die "$(msg project_not_found "$PROJECT_DIR")"
  PROJECT_PARENT=$(dirname "$PROJECT_DIR_ABS")
}

worktree_path_for() {
  local name="$1"
  printf '%s/%s%s\n' "$PROJECT_PARENT" "$WORKTREE_NAME_PREFIX" "$name"
}

worktree_ref_exists() {
  local target="$1"
  local line

  while IFS= read -r line; do
    case "$line" in
      worktree\ *)
        local candidate="${line#worktree }"
        if [ "$candidate" = "$target" ]; then
          return 0
        fi
        ;;
    esac
  done < <(git_project worktree list --porcelain)

  return 1
}

branch_for() {
  local name="$1"
  printf '%s%s\n' "$WORKTREE_BRANCH_PREFIX" "$name"
}

validate_worktree_name() {
  local candidate="${1:-}"

  if [ -z "$candidate" ]; then
    return 1
  fi

  if [[ "$candidate" =~ [[:space:]] ]]; then
    return 1
  fi

  case "$candidate" in
    .|'..'|*/*|*\\*|*~*)
      return 1
      ;;
  esac

  return 0
}

port_from_name() {
  local name="$1"
  local digits=""

  if [[ "$name" =~ ^([0-9]+)$ ]]; then
    digits="${BASH_REMATCH[1]}"
  elif [[ "$name" =~ ([0-9]+)$ ]]; then
    digits="${BASH_REMATCH[1]}"
  fi

  if [ -n "$digits" ]; then
    if [ "$digits" -ge 1024 ] && [ "$digits" -le 65535 ]; then
      printf '%s\n' "$digits"
      return 0
    fi
  fi

  printf ''
}

git_project() {
  git -C "$PROJECT_DIR_ABS" "$@"
}

copy_env_file() {
  local file_name="$1"
  local target_dir="$2"
  if [ -f "$PROJECT_DIR_ABS/$file_name" ]; then
    cp "$PROJECT_DIR_ABS/$file_name" "$target_dir/"
    info "$(msg copy_env_file "$file_name")"
  fi
}

command_exists_for_line() {
  local line="$1"
  if [ -z "$line" ]; then
    return 1
  fi

  local -a tokens
  IFS=' ' read -r -a tokens <<<"$line"
  if [ ${#tokens[@]} -eq 0 ]; then
    return 1
  fi

  local token
  for token in "${tokens[@]}"; do
    if [[ "$token" == *=* ]]; then
      continue
    fi
    if command -v "$token" >/dev/null 2>&1; then
      return 0
    fi
    return 1
  done

  return 1
}

run_install_command() {
  local worktree_path="${1:?worktree path is required}"
  local command_line="${2:-}"

  if [ -z "$command_line" ]; then
    info "$(msg install_skipped_no_command)"
    return
  fi

  if ! command_exists_for_line "$command_line"; then
    info "$(msg command_not_found "$command_line")"
    return
  fi

  info "$(msg installing_dependencies "$command_line")"
  (
    cd "$worktree_path"
    sh -c "$command_line" >&2
  )
}

command_slug_from_line() {
  local line="$1"
  if [ -z "$line" ]; then
    printf 'dev'
    return
  fi

  local slug
  slug=$(printf '%s' "$line" | tr "[:space:]/\\" '_')
  slug=${slug//[^A-Za-z0-9._-]/_}
  slug=${slug#_}
  slug=${slug%%_}
  if [ -z "$slug" ]; then
    slug='dev'
  fi
  slug=${slug:0:40}
  printf '%s' "$slug"
}

infer_install_command() {
  local worktree_path="${1:?worktree path is required}"

  if [ -f "$worktree_path/pnpm-lock.yaml" ]; then
    printf 'pnpm install --frozen-lockfile\n'
    return 0
  fi

  if [ -f "$worktree_path/yarn.lock" ]; then
    printf 'yarn install --frozen-lockfile\n'
    return 0
  fi

  if [ -f "$worktree_path/bun.lockb" ]; then
    printf 'bun install\n'
    return 0
  fi

  if [ -f "$worktree_path/package.json" ]; then
    if [ -f "$worktree_path/package-lock.json" ] || [ -f "$worktree_path/npm-shrinkwrap.json" ]; then
      printf 'npm ci\n'
      return 0
    fi
    printf 'npm install\n'
    return 0
  fi

  if [ -f "$worktree_path/poetry.lock" ]; then
    printf 'poetry install\n'
    return 0
  fi

  if [ -f "$worktree_path/Pipfile" ]; then
    printf 'pipenv install\n'
    return 0
  fi

  if [ -f "$worktree_path/requirements.txt" ]; then
    printf 'pip install -r requirements.txt\n'
    return 0
  fi

  if [ -f "$worktree_path/pyproject.toml" ]; then
    printf 'pip install -e .\n'
    return 0
  fi

  return 1
}

infer_serve_command() {
  local worktree_path="${1:?worktree path is required}"

  if [ -f "$worktree_path/pnpm-lock.yaml" ] && has_package_json_script "$worktree_path" "dev"; then
    printf 'pnpm dev\n'
    return 0
  fi

  if [ -f "$worktree_path/yarn.lock" ] && has_package_json_script "$worktree_path" "dev"; then
    printf 'yarn dev\n'
    return 0
  fi

  if [ -f "$worktree_path/bun.lockb" ] && has_package_json_script "$worktree_path" "dev"; then
    printf 'bun dev\n'
    return 0
  fi

  if [ -f "$worktree_path/package.json" ]; then
    if has_package_json_script "$worktree_path" "dev"; then
      printf 'npm run dev\n'
      return 0
    fi
    if has_package_json_script "$worktree_path" "start"; then
      printf 'npm run start\n'
      return 0
    fi
  fi

  if [ -f "$worktree_path/manage.py" ]; then
    printf 'python manage.py runserver\n'
    return 0
  fi

  if [ -f "$worktree_path/pyproject.toml" ] && [ -f "$worktree_path/app.py" ]; then
    printf 'python app.py\n'
    return 0
  fi

  if [ -f "$worktree_path/app.py" ]; then
    printf 'python app.py\n'
    return 0
  fi

  return 1
}

has_package_json_script() {
  local project_dir="${1:?project directory is required}"
  local script_name="${2:?script name is required}"
  local package_json="$project_dir/package.json"

  [ -f "$package_json" ] || return 1

  if command -v node >/dev/null 2>&1; then
    if node - "$package_json" "$script_name" >/dev/null 2>&1 <<'NODE'
const fs = require('fs');
const [pkgPath, scriptName] = process.argv.slice(2);
try {
  const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8')) || {};
  if (pkg.scripts && pkg.scripts[scriptName]) {
    process.exit(0);
  }
} catch (err) {}
process.exit(1);
NODE
    then
      return 0
    fi
  fi

  local python=""
  for candidate in python3 python; do
    if command -v "$candidate" >/dev/null 2>&1; then
      python="$candidate"
      break
    fi
  done

  if [ -n "$python" ]; then
    if "$python" - "$package_json" "$script_name" >/dev/null 2>&1 <<'PY'
import json
import sys

pkg_path = sys.argv[1]
script_name = sys.argv[2]

try:
    with open(pkg_path, 'r', encoding='utf-8') as f:
        data = json.load(f)
    scripts = data.get('scripts') or {}
    if scripts.get(script_name):
        sys.exit(0)
except Exception:
    pass

sys.exit(1)
PY
    then
      return 0
    fi
  fi

  return 1
}

start_dev_server() {
  local worktree_path="${1:?worktree path is required}"
  local command_line="${2:-}"
  local port="${3:-}"

  if [ -z "$command_line" ]; then
    info "$(msg dev_skipped_no_command)"
    return
  fi

  if ! command_exists_for_line "$command_line"; then
    info "$(msg command_not_found "$command_line")"
    return
  fi

  mkdir -p "$worktree_path/$SERVE_DEV_LOGGING_PATH"
  local slug
  slug=$(command_slug_from_line "$command_line")

  local log_file
  if [ -n "$port" ]; then
    log_file="$worktree_path/$SERVE_DEV_LOGGING_PATH/${slug}-${port}.log"
  else
    log_file="$worktree_path/$SERVE_DEV_LOGGING_PATH/${slug}.log"
  fi
  local pid_file="${log_file}.pid"

  info "$(msg dev_command "$command_line")"
  if [ -n "$port" ]; then
    info "$(msg start_dev_port "$port")"
  else
    info "$(msg start_dev_generic)"
  fi

  (
    cd "$worktree_path"
    if [ -n "$port" ]; then
      nohup env PORT="$port" sh -c "$command_line" > "$log_file" 2>&1 &
    else
      nohup sh -c "$command_line" > "$log_file" 2>&1 &
    fi
    printf '%s\n' "$!" > "$pid_file"
  )

  local pid=""
  if [ -f "$pid_file" ]; then
    pid=$(cat "$pid_file" 2>/dev/null || true)
  fi

  sleep 1

  if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
    if [ -n "$port" ]; then
      info "$(msg dev_started_port "$port")"
    else
      info "$(msg dev_started_default)"
    fi
  else
    local pid_display="${pid:-unknown}"
    info "$(msg dev_failed "$pid_display" "$log_file")"
  fi

  info "$(msg dev_log_hint "$log_file")"
}

maybe_warn_shell_integration() {
  local target_path="${1:-}"

  if [ -n "${WT_SHELL_WRAPPED:-}" ]; then
    return
  fi

  if [ ! -t 1 ]; then
    return
  fi

  if [ -z "$target_path" ] || [ ! -d "$target_path" ]; then
    return
  fi

  if [ "$AUTO_CD_HINT_SHOWN" = "1" ]; then
    return
  fi

  AUTO_CD_HINT_SHOWN=1

  local shell_name
  shell_name="${SHELL##*/}"
  if [ -z "$shell_name" ]; then
    shell_name="zsh"
  fi

  local hook_cmd="" rc_hint="reload your shell configuration" rc_file="" hook_present=0
  local hook_marker="# wt shell integration: auto-cd after wt add/path/main/remove/clean"

  case "$shell_name" in
    zsh)
      hook_cmd='wt shell-hook zsh >> ~/.zshrc'
      rc_hint='source ~/.zshrc'
      rc_file="$HOME/.zshrc"
      ;;
    bash)
      hook_cmd='wt shell-hook bash >> ~/.bashrc'
      rc_hint='source ~/.bashrc'
      rc_file="$HOME/.bashrc"
      ;;
    *)
      hook_cmd='wt shell-hook zsh >> ~/.zshrc'
      ;;
  esac

  if [ -n "$rc_file" ] && [ -f "$rc_file" ] && grep -Fq "$hook_marker" "$rc_file"; then
    hook_present=1
  fi

  if [ "$hook_present" -eq 1 ]; then
    info "$(msg auto_cd_pending "$rc_hint")"
    info "$(msg auto_cd_retry)"
    return
  fi

  info "$(msg auto_cd_disabled "$hook_cmd")"
  if [ "$rc_hint" = "reload your shell configuration" ]; then
    info "$(msg auto_cd_reload)"
  else
    info "$(msg auto_cd_execute "$rc_hint")"
  fi
}

cmd_list() {
  [ $# -eq 0 ] || die "$(msg list_no_args)"
  git_project worktree list
}

cmd_main() {
  [ $# -eq 0 ] || die "$(msg main_no_args)"
  maybe_warn_shell_integration "$PROJECT_DIR_ABS"
  printf '%s\n' "$PROJECT_DIR_ABS"
}

cmd_path() {
  if [ $# -ne 1 ]; then
    die "$(msg path_requires_name)"
  fi
  local name="$1"
  local target_path
  target_path=$(worktree_path_for "$name")
  if [ ! -d "$target_path" ]; then
    die "$(msg worktree_not_found "$name")"
  fi
  maybe_warn_shell_integration "$target_path"
  printf '%s\n' "$target_path"
}

cmd_add() {
  local name="$1"
  shift || true

  [ -n "$name" ] || die "$(msg add_requires_name)"
  if ! validate_worktree_name "$name"; then
    die "$(msg invalid_worktree_name "$name")"
  fi

  local run_install="$INSTALL_DEPS_ENABLED"
  local run_dev="$SERVE_DEV_ENABLED"
  local copy_env="$COPY_ENV_ENABLED"
  local branch=""
  local numeric_name=""
  local effective_port=""
  local base_branch="$WORKING_REPO_BRANCH"

  if [[ "$name" =~ ^[0-9]+$ ]]; then
    numeric_name="$name"
    if [ "$numeric_name" -ge 1 ] && [ "$numeric_name" -lt 1024 ]; then
      info "$(msg reserved_port "$numeric_name")"
    elif [ "$numeric_name" -gt 65535 ]; then
      info "$(msg port_out_of_range "$numeric_name")"
    fi
  fi

  while [ $# -gt 0 ]; do
    case "$1" in
      -h|--help|help)
        usage
        exit 0
        ;;
      --)
        shift
        break
        ;;
      -*)
        die "$(msg add_unknown_option "$1")"
        ;;
      *)
        die "$(msg unexpected_extra_argument "$1")"
        ;;
    esac
    shift || true
  done

  if [ $# -gt 0 ]; then
    die "$(msg unexpected_extra_argument "$1")"
  fi

  if [ "$run_dev" -eq 1 ]; then
    effective_port=$(port_from_name "$name")

    if [ -z "$effective_port" ] && [ -n "$numeric_name" ]; then
      if [ "$numeric_name" -lt 1024 ]; then
        info "$(msg fallback_default_port)"
      elif [ "$numeric_name" -gt 65535 ]; then
        info "$(msg fallback_default_port)"
      fi
    fi
  fi

  local worktree_path
  worktree_path=$(worktree_path_for "$name")

  if [ -e "$worktree_path" ]; then
    die "$(msg worktree_exists "$worktree_path")"
  fi

  if [ -z "$branch" ]; then
    branch=$(branch_for "$name")
  fi

  info "$(msg creating_worktree "$worktree_path" "$branch")"
  if [ -n "$base_branch" ]; then
    git_project worktree add -b "$branch" "$worktree_path" "$base_branch" >&2
  else
    git_project worktree add -b "$branch" "$worktree_path" >&2
  fi
  info "$(msg worktree_created)"

  if [ "$copy_env" -eq 1 ]; then
    if [ ${#COPY_ENV_FILE_SELECTION[@]} -gt 0 ]; then
      local env_file
      for env_file in "${COPY_ENV_FILE_SELECTION[@]}"; do
        [ -n "$env_file" ] || continue
        copy_env_file "$env_file" "$worktree_path"
      done
    fi
  fi

  local install_command="$INSTALL_DEPS_COMMAND"
  local serve_command="$SERVE_DEV_COMMAND"
  local install_detected=0
  local serve_detected=0

  if [ "$run_install" -eq 1 ] && [ -z "$install_command" ]; then
    if install_command=$(infer_install_command "$worktree_path"); then
      info "$(msg install_detected "$install_command")"
      install_detected=1
    fi
  fi

  if [ "$run_dev" -eq 1 ] && [ -z "$serve_command" ]; then
    if serve_command=$(infer_serve_command "$worktree_path"); then
      info "$(msg serve_detected "$serve_command")"
      serve_detected=1
    fi
  fi

  if [ "$install_detected" -eq 1 ]; then
    config_set "add.install-deps.command" "$install_command"
  fi

  if [ "$serve_detected" -eq 1 ]; then
    config_set "add.serve-dev.command" "$serve_command"
  fi

  if [ "$run_install" -eq 1 ]; then
    run_install_command "$worktree_path" "$install_command"
  fi

  if [ "$run_dev" -eq 1 ]; then
    start_dev_server "$worktree_path" "$serve_command" "$effective_port"
  else
    info "$(msg dev_skipped_config)"
  fi

  info "$(msg worktree_ready "$worktree_path")"
  maybe_warn_shell_integration "$worktree_path"
  printf '%s\n' "$worktree_path"
}

config_print_effective() {
  if ! config_ensure_seeded; then
    return 1
  fi

  [ -f "$CONFIG_FILE" ] || return 1

  cat "$CONFIG_FILE"
}

config_usage() {
  case "$LANGUAGE" in
    zh)
      cat <<'CONFIG_USAGE_ZH'
wt config - 查看或更新 worktree.sh 配置

子命令:
  wt config list                 显示生效配置（包含默认值）
  wt config get <key> [--stored] 默认输出生效配置项；使用 --stored 仅读取配置文件
  wt config set <key> <value>    将配置写入 ~/.worktree.sh
  wt config unset <key>          从 ~/.worktree.sh 移除配置

快捷方式:
  wt config <key>                等同于 get（生效值）
  wt config --stored <key>       等同于 get --stored
  wt config <key> <value>        等同于 set

支持的键:
  language                        CLI 显示语言（en|zh，默认 en）
  repo.path                       默认维护的仓库根目录（由 wt init 设置）
  repo.branch                     新 worktree 的默认分支（可选）
  add.branch-prefix               新 worktree 分支名前缀（默认 feat/）
  add.copy-env.enabled            是否在 wt add 时复制环境文件
  add.copy-env.files              被复制的环境文件列表（JSON 数组）
  add.install-deps.enabled        是否在 wt add 时安装依赖
  add.install-deps.command        安装依赖使用的命令（留空则自动推断）
  add.serve-dev.enabled           是否在 wt add 后启动开发服务
  add.serve-dev.command           启动开发服务的命令（留空则自动推断）
  add.serve-dev.logging-path      Dev 服务日志所在子目录（默认: tmp）

说明:
  配置以 ~/.worktree.sh/config.kv 为准，采用 key=value 文本格式，不再支持通过环境变量临时覆盖。
  布尔值接受 true/false/1/0/yes/no/on/off。
CONFIG_USAGE_ZH
      ;;
    *)
      cat <<'CONFIG_USAGE_EN'
wt config - Inspect or update worktree.sh configuration

Subcommands:
  wt config list                 Show effective configuration (includes defaults)
  wt config get <key> [--stored] Print effective value; add --stored to read the raw file only
  wt config set <key> <value>    Persist value in ~/.worktree.sh
  wt config unset <key>          Remove key from ~/.worktree.sh

Shortcuts:
  wt config <key>                Shortcut for effective get
  wt config --stored <key>       Shortcut for get --stored
  wt config <key> <value>        Shortcut for set

Supported keys:
  language                        CLI language (en or zh; default: en)
  repo.path                       Root directory of the tracked repository (set by wt init)
  repo.branch                     Default branch for new worktrees (optional)
  add.branch-prefix               Branch name prefix used for new worktrees (default: feat/)
  add.copy-env.enabled            Whether wt add copies environment files
  add.copy-env.files              Environment files to copy (JSON array)
  add.install-deps.enabled        Whether wt add installs dependencies
  add.install-deps.command        Command used to install dependencies (empty = auto-detect)
  add.serve-dev.enabled           Whether wt add starts the dev service
  add.serve-dev.command           Command used to start the dev service (empty = auto-detect)
  add.serve-dev.logging-path      Subdirectory for dev logs (default: tmp)

Notes:
  Runtime settings come solely from ~/.worktree.sh/config.kv (key=value text); environment overrides are ignored.
  Boolean values accept true/false/1/0/yes/no/on/off.
CONFIG_USAGE_EN
      ;;
  esac
}

cmd_config() {
  if [ $# -eq 0 ]; then
    config_usage
    return
  fi

  if [ "$1" = "--stored" ]; then
    shift || die "$(msg config_get_requires_key)"
    set -- get --stored "$@"
  fi

  case "$1" in
    list|--list)
      if [ $# -ne 1 ]; then
        die "$(msg config_list_no_args)"
      fi
      init_settings
      config_print_effective
      ;;
    get|--get)
      shift || die "$(msg config_get_requires_key)"

      local stored_only=0
      while [ $# -gt 0 ]; do
        case "$1" in
          --stored)
            stored_only=1
            shift || true
            ;;
          --*)
            die "$(msg config_unknown_option "$1")"
            ;;
          *)
            break
            ;;
        esac
      done

      if [ $# -ne 1 ]; then
        die "$(msg config_get_requires_exactly_one)"
      fi

      local key="$1"
      local value
      if [ "$stored_only" -eq 1 ]; then
        if value=$(config_get "$key" 2>/dev/null); then
          printf '%s\n' "$value"
        else
          die "$(msg config_key_not_found "$key")"
        fi
      else
        if value=$(config_get_or_default "$key" 2>/dev/null); then
          printf '%s\n' "$value"
        else
          die "$(msg config_key_not_found "$key")"
        fi
      fi
      ;;
    set|--set)
      shift || die "$(msg config_set_requires)"
      if [ $# -ne 2 ]; then
        die "$(msg config_set_requires)"
      fi
      local key="$1"
      shift
      local value="$1"
      if [ "$key" = "language" ]; then
        if normalized=$(normalize_language "$value" 2>/dev/null); then
          value=$(language_code_to_config_value "$normalized")
        else
          die "$(msg invalid_language "$value")"
        fi
      fi
      config_set "$key" "$value"
      ;;
    unset|--unset)
      shift || die "$(msg config_unset_requires_key)"
      if [ $# -ne 1 ]; then
        die "$(msg config_unset_requires_exactly_one)"
      fi
      local key="$1"
      config_unset "$key"
      ;;
    -h|--help|help)
      config_usage
      ;;
    --*)
      die "$(msg config_unknown_option "$1")"
      ;;
    *)
      local stored_only=0
      if [ $# -gt 0 ] && [ "$1" = "--stored" ]; then
        stored_only=1
        shift || true
      fi

      if [ $# -eq 1 ]; then
        local key="$1"
        local value
        if [ "$stored_only" -eq 1 ]; then
          if value=$(config_get "$key" 2>/dev/null); then
            printf '%s\n' "$value"
          else
            die "$(msg config_key_not_found "$key")"
          fi
        else
          if value=$(config_get_or_default "$key" 2>/dev/null); then
            printf '%s\n' "$value"
          else
            die "$(msg config_key_not_found "$key")"
          fi
        fi
      elif [ $# -eq 2 ]; then
        local key="$1"
        local value="$2"
        if [ "$key" = "language" ]; then
          if normalized=$(normalize_language "$value" 2>/dev/null); then
            value=$(language_code_to_config_value "$normalized")
          else
            die "$(msg invalid_language "$value")"
          fi
        fi
        config_set "$key" "$value"
      elif [ "$stored_only" -eq 1 ]; then
        die "$(msg config_get_requires_key)"
      else
        die "$(msg config_expect_key_or_value)"
      fi
      ;;
  esac
}

cmd_shell_hook() {
  if [ $# -eq 0 ]; then
    die "$(msg shell_hook_requires_shell)"
  fi

  case "$1" in
    -h|--help|help)
      case "$LANGUAGE" in
        zh)
          cat <<'HOOK_USAGE_ZH'
wt shell-hook 用法:
  wt shell-hook zsh
  wt shell-hook bash

将输出通过 eval/source 加载以安装包装函数，例如：
  eval "$(wt shell-hook zsh)"
HOOK_USAGE_ZH
          ;;
        *)
          cat <<'HOOK_USAGE_EN'
wt shell-hook usage:
  wt shell-hook zsh
  wt shell-hook bash

Pipe the output into eval/source to install the wrapper, e.g.
  eval "$(wt shell-hook zsh)"
HOOK_USAGE_EN
          ;;
      esac
      return
      ;;
  esac

  local shell="$1"
  case "$shell" in
    zsh|bash)
      cat <<'WT_HOOK'
# wt shell integration: auto-cd after wt add/path/main/remove/clean
wt() {
  local __wt_out __wt_status __wt_cmd __wt_should_cd=0
  __wt_out="$(WT_SHELL_WRAPPED=1 command wt "$@")"
  __wt_status=$?

  if [ $__wt_status -ne 0 ]; then
    if [ -n "$__wt_out" ]; then
      printf '%s\n' "$__wt_out"
    fi
    return $__wt_status
  fi

  if [ $# -eq 0 ]; then
    __wt_cmd="list"
  else
    __wt_cmd="$1"
  fi

  case "$__wt_cmd" in
    add|main|path)
      __wt_should_cd=1
      ;;
    remove|rm|clean)
      __wt_should_cd=1
      ;;
    config|list|help|-h|--help|--version|version)
      __wt_should_cd=0
      ;;
    -*)
      __wt_should_cd=0
      ;;
    *)
      __wt_should_cd=1
      ;;
  esac

  if [ $__wt_should_cd -eq 1 ] && [ -n "$__wt_out" ] && [ -d "$__wt_out" ]; then
    cd "$__wt_out" || return $?
    return 0
  fi

  if [ -n "$__wt_out" ]; then
    printf '%s\n' "$__wt_out"
  fi
}
# wt shell integration: end
WT_HOOK
      ;;
    *)
      die "$(msg shell_hook_unsupported_shell "$shell")"
      ;;
  esac
}

uninstall_remove_shell_hook() {
  local shell_type="$1"
  local hook_file=""
  local hook_marker="# wt shell integration: auto-cd after wt add/path/main/remove/clean"
  local marker_end="# wt shell integration: end"

  case "$shell_type" in
    zsh)
      hook_file="$HOME/.zshrc"
      ;;
    bash)
      hook_file="$HOME/.bashrc"
      ;;
    *)
      info "$(msg uninstall_unknown_shell_type "$shell_type")"
      return 0
      ;;
  esac

  if [ ! -f "$hook_file" ]; then
    info "$(msg uninstall_shell_config_missing "$hook_file")"
    return 0
  fi

  if ! grep -Fq "$hook_marker" "$hook_file"; then
    info "$(msg uninstall_shell_hook_missing "$hook_file")"
    return 0
  fi

  local timestamp
  timestamp=$(date +%Y%m%d_%H%M%S)
  cp "$hook_file" "${hook_file}.backup.${timestamp}"
  info "$(msg uninstall_backup_created "$hook_file" "$timestamp")"

  local tmpfile
  tmpfile=$(mktemp) || die "$(msg temp_file_failed)"

  awk -v start="$hook_marker" -v finish="$marker_end" '
    BEGIN { mode=0 }
    {
      if (mode==0) {
        if ($0 == start) { mode=1; next }
        print
        next
      }

      if (mode==1) {
        if ($0 == finish) { mode=2; next }
        next
      }

      if (mode==2) {
        if ($0 ~ /^[[:space:]]*$/) { mode=0; next }
        mode=0
        print
        next
      }
    }
  ' "$hook_file" > "$tmpfile"

  mv "$tmpfile" "$hook_file"
  info "$(msg uninstall_shell_hook_removed "$hook_file")"
}

uninstall_backup_config() {
  local config_path="$CONFIG_FILE"
  local default_dir="$CONFIG_DIR_DEFAULT"
  local timestamp
  timestamp=$(date +%Y%m%d_%H%M%S)

  if [ "$config_path" = "$CONFIG_FILE_DEFAULT" ] && [ -d "$default_dir" ]; then
    local backup_path="${default_dir}.backup.${timestamp}"
    local candidate="$backup_path"
    local idx=1
    while [ -e "$candidate" ]; do
      candidate="${backup_path}.${idx}"
      idx=$((idx + 1))
    done
    mv "$default_dir" "$candidate"
    info "$(msg uninstall_config_backup_created "$default_dir" "$candidate")"
    return
  fi

  if [ -f "$config_path" ]; then
    local backup_path="${config_path}.backup.${timestamp}"
    local candidate="$backup_path"
    local idx=1
    while [ -e "$candidate" ]; do
      candidate="${backup_path}.${idx}"
      idx=$((idx + 1))
    done
    mv "$config_path" "$candidate"
    info "$(msg uninstall_config_backup_created "$config_path" "$candidate")"
  fi
}

cmd_uninstall() {
  local prefix="${WT_INSTALL_PREFIX:-$HOME/.local/bin}"
  local shell_type=""

  while [ $# -gt 0 ]; do
    case "$1" in
      --shell)
        shift || die "$(msg uninstall_requires_shell_value)"
        shell_type="$1"
        ;;
      --prefix)
        shift || die "$(msg uninstall_requires_prefix_value)"
        prefix="$1"
        ;;
      -h|--help|help)
        case "$LANGUAGE" in
          zh)
            cat <<'UNINSTALL_USAGE_ZH'
wt uninstall 用法:
  wt uninstall [--shell <shell>] [--prefix <dir>]

选项:
  --shell <shell>   指定要清理的 shell（zsh|bash|none；默认自动检测）
  --prefix <dir>    wt 安装目录（默认 $HOME/.local/bin）
  --help            查看帮助
UNINSTALL_USAGE_ZH
            ;;
          *)
            cat <<'UNINSTALL_USAGE_EN'
wt uninstall usage:
  wt uninstall [--shell <shell>] [--prefix <dir>]

Options:
  --shell <shell>   Shell to clean hooks for (zsh|bash|none; default: auto-detect)
  --prefix <dir>    Directory where wt is installed (default: $HOME/.local/bin)
  --help            Show this help
UNINSTALL_USAGE_EN
            ;;
        esac
        return
        ;;
      --)
        shift
        break
        ;;
      -*)
        die "$(msg uninstall_unknown_option "$1")"
        ;;
      *)
        die "$(msg uninstall_no_positional)"
        ;;
    esac
    shift || true
  done

  if [ $# -gt 0 ]; then
    die "$(msg uninstall_no_positional)"
  fi

  if [ -z "$shell_type" ]; then
    shell_type=$(detect_shell_type)
    info "$(msg uninstall_auto_detected_shell "$shell_type")"
  fi

  case "$shell_type" in
    zsh|bash|none) ;;
    *)
      die "$(msg uninstall_invalid_shell "$shell_type")"
      ;;
  esac

  local wt_bin="$prefix/wt"
  if [ -f "$wt_bin" ]; then
    rm -f "$wt_bin"
    info "$(msg uninstall_removed_binary "$wt_bin")"
  else
    info "$(msg uninstall_binary_missing "$wt_bin")"
  fi

  local messages_file="$prefix/messages.sh"
  if [ -f "$messages_file" ]; then
    rm -f "$messages_file"
    info "$(msg uninstall_removed_messages "$messages_file")"
  fi

  if [ "$shell_type" != "none" ]; then
    uninstall_remove_shell_hook "$shell_type"
  else
    info "$(msg uninstall_skip_shell_cleanup)"
  fi

  uninstall_backup_config

  info "$(msg uninstall_complete)"
  info "$(msg uninstall_worktrees_preserved)"
}

cmd_update() {
  local prefix="${WT_INSTALL_PREFIX:-$HOME/.local/bin}"
  local npm_package="$WT_NPM_PACKAGE_NAME"

  while [ $# -gt 0 ]; do
    case "$1" in
      -h|--help|help)
        case "$LANGUAGE" in
          zh)
            cat <<'UPDATE_USAGE_ZH'
wt update 用法:
  wt update

说明:
  - 从官方仓库下载最新 wt 和 messages.sh
  - 默认更新 ~/.local/bin 下的安装（可通过 WT_INSTALL_PREFIX 环境变量覆盖）
  - 需要 curl 命令
UPDATE_USAGE_ZH
            ;;
          *)
            cat <<'UPDATE_USAGE_EN'
wt update usage:
  wt update

Details:
  - Downloads the latest wt and messages.sh from the official repository
  - Updates the installation in ~/.local/bin (override with WT_INSTALL_PREFIX environment variable)
  - Requires curl to be installed
UPDATE_USAGE_EN
            ;;
        esac
        return
        ;;
      --)
        shift
        break
        ;;
      -*)
        die "$(msg update_unknown_option "$1")"
        ;;
      *)
        die "$(msg update_no_positional)"
        ;;
    esac
    shift || true
  done

  if [ $# -gt 0 ]; then
    die "$(msg update_no_positional)"
  fi

  if command -v npm >/dev/null 2>&1; then
    if npm ls -g --depth=0 "$npm_package" >/dev/null 2>&1; then
      info "$(msg update_npm_hint)"
      info "$(msg update_npm_command)"
      return
    fi

    case "$SCRIPT_DIR" in
      */node_modules/*)
        info "$(msg update_npm_hint)"
        info "$(msg update_npm_command)"
        return
        ;;
    esac

    info "$(msg update_legacy_recommend_npm)"
  fi

  command -v curl >/dev/null 2>&1 || die "$(msg curl_required)"

  local tmpdir
  tmpdir=$(mktemp -d 2>/dev/null) || die "$(msg temp_dir_failed)"

  local wt_tmp="$tmpdir/wt"
  local messages_tmp="$tmpdir/messages.sh"

  info "$(msg update_fetch "$WT_UPDATE_WT_URL")"
  if ! curl -fsSL "$WT_UPDATE_WT_URL" -o "$wt_tmp"; then
    rm -rf "$tmpdir"
    die "$(msg update_download_failed "$WT_UPDATE_WT_URL")"
  fi

  info "$(msg update_fetch "$WT_UPDATE_MESSAGES_URL")"
  if ! curl -fsSL "$WT_UPDATE_MESSAGES_URL" -o "$messages_tmp"; then
    rm -rf "$tmpdir"
    die "$(msg update_download_failed "$WT_UPDATE_MESSAGES_URL")"
  fi

  if ! install -d "$prefix"; then
    rm -rf "$tmpdir"
    die "$(msg update_create_prefix_failed "$prefix")"
  fi

  local updated=0
  local target_wt="$prefix/wt"
  if [ -f "$target_wt" ] && cmp -s "$target_wt" "$wt_tmp"; then
    info "$(msg update_binary_unchanged "$target_wt")"
  else
    if ! install -m 0755 "$wt_tmp" "$target_wt"; then
      rm -rf "$tmpdir"
      die "$(msg update_install_failed "$target_wt")"
    fi
    info "$(msg update_binary_installed "$target_wt")"
    updated=1
  fi

  local target_messages="$prefix/messages.sh"
  if [ -f "$target_messages" ] && cmp -s "$target_messages" "$messages_tmp"; then
    info "$(msg update_messages_unchanged "$target_messages")"
  else
    if ! install -m 0644 "$messages_tmp" "$target_messages"; then
      rm -rf "$tmpdir"
      die "$(msg update_install_failed "$target_messages")"
    fi
    info "$(msg update_messages_installed "$target_messages")"
    updated=1
  fi

  rm -rf "$tmpdir"

  if [ "$updated" -eq 0 ]; then
    info "$(msg update_already_latest)"
  else
    info "$(msg update_complete)"
  fi
}

cmd_init() {
  local branch=""
  while [ $# -gt 0 ]; do
    case "$1" in
      --branch|branch)
        shift || die "$(msg branch_requires_value)"
        branch="$1"
        ;;
      --help|help)
        case "$LANGUAGE" in
          zh)
            cat <<'INIT_USAGE_ZH'
wt init 用法:
  wt init [branch <name>]

请在 franxx.store 仓库根目录运行，以将设置写入 ~/.worktree.sh：
- 设置 repo.path 为仓库根目录。
- 提供 branch <name> 时设置 repo.branch（默认使用当前分支）。
INIT_USAGE_ZH
            ;;
          *)
            cat <<'INIT_USAGE_EN'
wt init usage:
  wt init [branch <name>]

Run inside the franxx.store repository to capture settings into ~/.worktree.sh.
- Sets repo.path to the repo root.
- Optionally sets repo.branch when branch <name> is provided (defaults to current branch).
INIT_USAGE_EN
            ;;
        esac
        return
        ;;
      -*)
        die "$(msg init_unknown_option "$1")"
        ;;
      *)
        die "$(msg init_no_positional)"
        ;;
    esac
    shift || true
  done

  local repo_root repo_root_abs home_dir_abs
  repo_root=$(git rev-parse --show-toplevel 2>/dev/null) || die "$(msg init_run_inside_git)"
  if ! repo_root_abs=$(cd "$repo_root" 2>/dev/null && pwd -P); then
    repo_root_abs="$repo_root"
  fi
  if ! home_dir_abs=$(cd "$HOME" 2>/dev/null && pwd -P); then
    home_dir_abs="$HOME"
  fi

  if [ "$repo_root_abs" = "$home_dir_abs" ]; then
    die "$(msg init_forbid_home "$repo_root")"
  fi
  config_set "repo.path" "$repo_root"
  info "$(msg init_set_project "$repo_root")"

  if [ -z "$branch" ]; then
    branch=$(git symbolic-ref --quiet --short HEAD 2>/dev/null || true)
  fi

  if [ -n "$branch" ]; then
    config_set "repo.branch" "$branch"
    info "$(msg init_set_branch "$branch")"
  fi

  info "$(msg init_done)"
}

remove_worktree_by_name() {
  if [ $# -ne 2 ]; then
    return 1
  fi

  local name="$1"
  local current_abs="$2"
  local target_path
  local removing_current=0

  target_path=$(worktree_path_for "$name")
  if [ ! -d "$target_path" ] && ! worktree_ref_exists "$target_path"; then
    die "$(msg worktree_not_found "$name")"
  fi

  if [ "$current_abs" = "$target_path" ]; then
    removing_current=1
  fi

  info "$(msg removing_worktree "$target_path")"
  local removal_succeeded=0
  if git_project worktree remove "$target_path" --force >&2; then
    removal_succeeded=1
  else
    if [ ! -d "$target_path" ]; then
      git_project worktree prune --expire now >&2 || true
      if ! worktree_ref_exists "$target_path"; then
        removal_succeeded=1
      fi
    fi
  fi

  if [ "$removal_succeeded" -eq 0 ]; then
    die "$(msg remove_failed)"
  fi

  local branch
  branch=$(branch_for "$name")
  if git_project show-ref --verify --quiet "refs/heads/$branch"; then
    git_project branch -D "$branch" >&2 || true
    info "$(msg removed_branch "$branch")"
  fi

  info "$(msg worktree_removed "$name")"

  if [ "$removing_current" -eq 1 ]; then
    info "$(msg current_worktree_removed)"
    maybe_warn_shell_integration "$PROJECT_DIR_ABS"
    printf '%s\n' "$PROJECT_DIR_ABS"
  fi
}

cmd_remove() {
  local assume_yes=0
  local -a names=()

  while [ $# -gt 0 ]; do
    case "$1" in
      -y|--yes|yes)
        assume_yes=1
        ;;
      -h|--help|help)
        usage
        exit 0
        ;;
      -*)
        die "$(msg remove_unknown_option "$1")"
        ;;
      *)
        names+=("$1")
        ;;
    esac
    shift || true
  done

  local current_abs
  current_abs=$(pwd -P)

  if [ ${#names[@]} -eq 0 ]; then
    if [ "$current_abs" = "$PROJECT_DIR_ABS" ]; then
      die "$(msg cannot_remove_main)"
    fi

    local current_base
    current_base=$(basename "$current_abs")
    if [[ "$current_base" != "$WORKTREE_NAME_PREFIX"* ]]; then
      die "$(msg specify_worktree_or_inside)"
    fi

    local derived_name
    derived_name="${current_base#"$WORKTREE_NAME_PREFIX"}"

    if [ "$assume_yes" -eq 0 ]; then
      printf '%s ' "$(msg remove_confirm_prompt "$derived_name")" >&2
      read -r reply
      if [ -n "$reply" ] && [[ ! "$reply" =~ ^[Yy]$ ]]; then
        info "$(msg aborted)"
        return 1
      fi
    fi

    remove_worktree_by_name "$derived_name" "$current_abs"
    return
  fi

  local name
  for name in "${names[@]}"; do
    remove_worktree_by_name "$name" "$current_abs"
  done
}

cmd_clean() {
  [ $# -eq 0 ] || die "$(msg clean_no_args)"
  local removed=0
  local current_abs
  current_abs=$(pwd -P)
  local current_removed=0

  while IFS= read -r line; do
    case "$line" in
      worktree\ *)
        local worktree_path base suffix branch_name
        worktree_path="${line#worktree }"
        base=$(basename "$worktree_path")
        if [[ "$base" == "$WORKTREE_NAME_PREFIX"* ]]; then
          suffix="${base#"$WORKTREE_NAME_PREFIX"}"
          if [[ "$suffix" =~ ^[0-9]+$ ]]; then
            info "$(msg cleaning_worktree "$suffix")"
            git_project worktree remove "$worktree_path" --force >&2 || true
            branch_name=$(branch_for "$suffix")
            git_project branch -D "$branch_name" >/dev/null 2>&1 || true
            removed=$((removed + 1))
            if [ "$current_abs" = "$worktree_path" ]; then
              current_removed=1
            fi
          fi
        fi
        ;;
    esac
  done < <(git_project worktree list --porcelain)

  if [ "$removed" -gt 0 ]; then
    info "$(msg cleaned_count "$removed")"
  else
    info "$(msg cleaned_none)"
  fi

  if [ "$current_removed" -eq 1 ]; then
    info "$(msg clean_switch_back)"
    maybe_warn_shell_integration "$PROJECT_DIR_ABS"
    printf '%s\n' "$PROJECT_DIR_ABS"
  fi
}

main() {
  init_settings
  ensure_messages_loaded

  local command=""
  while [ $# -gt 0 ]; do
    case "$1" in
      --)
        shift
        break
        ;;
      -*)
        usage_exit 1
        ;;
      *)
        break
        ;;
    esac
    shift || true
  done

  if [ $# -eq 0 ]; then
    command="help"
  else
    command="$1"
    shift || true
  fi

  case "$command" in
    config)
      cmd_config "$@"
      return
      ;;
    shell-hook)
      cmd_shell_hook "$@"
      return
      ;;
    uninstall)
      cmd_uninstall "$@"
      return
      ;;
    update)
      cmd_update "$@"
      return
      ;;
    init)
      cmd_init "$@"
      return
      ;;
    help)
      usage
      return
      ;;
    version)
      printf '%s\n' "$VERSION"
      return
      ;;
  esac

  resolve_project

  case "$command" in
    list)
      cmd_list "$@"
      ;;
    add)
      [ $# -ge 1 ] || die "$(msg add_requires_name)"
      cmd_add "$@"
      ;;
    rm|remove)
      cmd_remove "$@"
      ;;
    clean)
      cmd_clean "$@"
      ;;
    main)
      cmd_main "$@"
      ;;
    path)
      cmd_path "$@"
      ;;
    *)
      cmd_path "$command" "$@"
      ;;
  esac
}

main "$@"
