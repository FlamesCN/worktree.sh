#!/usr/bin/env bash
set -euo pipefail

VERSION="0.1.0"

CONFIG_DIR_DEFAULT="$HOME/.wt-cli"
CONFIG_FILE_DEFAULT="$CONFIG_DIR_DEFAULT/config.json"

if [ -n "${WT_CONFIG_FILE:-}" ]; then
  CONFIG_FILE="$WT_CONFIG_FILE"
else
  CONFIG_FILE="$CONFIG_FILE_DEFAULT"
fi

if [ -n "${WT_CONFIG_CACHE_FILE:-}" ]; then
  CONFIG_CACHE_FILE="$WT_CONFIG_CACHE_FILE"
else
  CONFIG_CACHE_FILE="$CONFIG_FILE.cache"
fi

DEFAULT_PROJECT_DIR_DEFAULT="${HOME}/Developer/your-project"
LOG_SUBDIR_DEFAULT="tmp"
AUTO_START_DEV_DEFAULT=1
ADD_INSTALL_DEPS_DEFAULT=1
ADD_COPY_ENV_DEFAULT=1
DEFAULT_PROJECT_DIR="$DEFAULT_PROJECT_DIR_DEFAULT"
WORKTREE_PREFIX_DEFAULT="$(basename "$DEFAULT_PROJECT_DIR_DEFAULT")."
WORKTREE_PREFIX="${WT_WORKTREE_PREFIX:-$WORKTREE_PREFIX_DEFAULT}"
BRANCH_PREFIX="${WT_BRANCH_PREFIX:-feat/}"
LOG_SUBDIR="$LOG_SUBDIR_DEFAULT"
NPM_BIN="${WT_NPM_BIN:-npm}"
AUTO_START_DEV="$AUTO_START_DEV_DEFAULT"
ADD_INSTALL_DEPS="$ADD_INSTALL_DEPS_DEFAULT"
ADD_COPY_ENV="$ADD_COPY_ENV_DEFAULT"
COPY_ENV_FILES_DEFAULT=(".env" ".env_local")
COPY_ENV_FILES=()
INSTALL_DEPS_COMMAND_DEFAULT=""
INSTALL_DEPS_COMMAND=""
SERVE_DEV_COMMAND_DEFAULT=""
SERVE_DEV_COMMAND=""
LANGUAGE_DEFAULT="en"
LANGUAGE="$LANGUAGE_DEFAULT"

SCRIPT_SOURCE="${BASH_SOURCE[0]:-${0}}"
SCRIPT_DIR=$(cd "$(dirname "$SCRIPT_SOURCE")" 2>/dev/null && pwd || pwd)
MESSAGES_FILE="$SCRIPT_DIR/messages.sh"
MESSAGES_LOADED=0

ensure_messages_loaded() {
  if [ "$MESSAGES_LOADED" = "1" ]; then
    return
  fi

  if [ -f "$MESSAGES_FILE" ]; then
    # shellcheck disable=SC1090
    . "$MESSAGES_FILE"
    MESSAGES_LOADED=1
    return
  fi

  printf 'wt: missing messages file (%s)\n' "$MESSAGES_FILE" >&2
  exit 1
}

normalize_language() {
  if [ $# -ne 1 ]; then
    return 1
  fi

  local raw
  raw=$(printf '%s' "$1" | tr '[:upper:]' '[:lower:]')
  raw=${raw%%.*}
  raw=${raw//-/_}

  case "$raw" in
    zh|zh_cn|zh_hans|zh_hant|zh_tw|cn|chinese|中文)
      printf 'zh\n'
      return 0
      ;;
    en|en_us|en_gb|english|英语)
      printf 'en\n'
      return 0
      ;;
  esac

  return 1
}

language_code_to_config_value() {
  case "${1:-}" in
    zh)
      printf 'zh\n'
      ;;
    en)
      printf 'en\n'
      ;;
    *)
      printf '%s\n' "${1:-}"
      ;;
  esac
}

init_language() {
  LANGUAGE="$LANGUAGE_DEFAULT"

  local value normalized
  if value=$(config_get "language" 2>/dev/null); then
    if normalized=$(normalize_language "$value" 2>/dev/null); then
      LANGUAGE="$normalized"
    fi
  fi

  for env_var in WT_LANGUAGE WT_LANG LANG; do
    value="${!env_var:-}"
    if [ -n "$value" ]; then
      if normalized=$(normalize_language "$value" 2>/dev/null); then
        LANGUAGE="$normalized"
        break
      fi
    fi
  done
}

msg() {
  ensure_messages_loaded
  local key
  key="${1:-}"
  shift || true
  case "$LANGUAGE" in
    zh)
      msg_zh "$key" "$@"
      ;;
    *)
      msg_en "$key" "$@"
      ;;
  esac
}



parse_bool() {
  if [ $# -ne 1 ]; then
    return 1
  fi
  local lower
  lower=$(printf '%s' "$1" | tr '[:upper:]' '[:lower:]')
  case "$lower" in
    1|true|yes|on)
      printf '1\n'
      ;;
    0|false|no|off)
      printf '0\n'
      ;;
    *)
      return 1
      ;;
  esac
}

CONFIG_PYTHON_BIN=""
CONFIG_KV_DELIM=$'\x1f'

CONFIG_CACHE_LOADED=0
CONFIG_CACHE_KEYS=()
CONFIG_CACHE_TYPES=()
CONFIG_CACHE_VALUES=()
CONFIG_CACHE_ARRAY_KEYS=()
CONFIG_CACHE_ARRAY_VALUES=()

config_cache_reset() {
  CONFIG_CACHE_LOADED=0
  CONFIG_CACHE_KEYS=()
  CONFIG_CACHE_TYPES=()
  CONFIG_CACHE_VALUES=()
  CONFIG_CACHE_ARRAY_KEYS=()
  CONFIG_CACHE_ARRAY_VALUES=()
}

config_cache_array_append() {
  local array_key="$1"
  local array_value="$2"
  local idx

  for idx in "${!CONFIG_CACHE_ARRAY_KEYS[@]}"; do
    if [ "${CONFIG_CACHE_ARRAY_KEYS[$idx]}" = "$array_key" ]; then
      if [ -n "${CONFIG_CACHE_ARRAY_VALUES[$idx]}" ]; then
        CONFIG_CACHE_ARRAY_VALUES[$idx]+=$'\n'"$array_value"
      else
        CONFIG_CACHE_ARRAY_VALUES[$idx]="$array_value"
      fi
      return
    fi
  done

  CONFIG_CACHE_ARRAY_KEYS+=("$array_key")
  CONFIG_CACHE_ARRAY_VALUES+=("$array_value")
}

config_collect_entries() {
  if [ ! -f "$CONFIG_FILE" ] || [ ! -s "$CONFIG_FILE" ]; then
    if [ -n "${CONFIG_CACHE_FILE:-}" ]; then
      rm -f "$CONFIG_CACHE_FILE"
    fi
    return 0
  fi

  if [ -n "${CONFIG_CACHE_FILE:-}" ] && [ -f "$CONFIG_CACHE_FILE" ] && [ "$CONFIG_CACHE_FILE" -nt "$CONFIG_FILE" ]; then
    cat "$CONFIG_CACHE_FILE"
    return 0
  fi

  local python_bin
  python_bin=$(config_python_or_die)

  local -a python_cmd=("$python_bin" -S -B)

  local tmp
  tmp=$(mktemp "${TMPDIR:-/tmp}/wt-config-cache.XXXXXX") || return 1

  if ! "${python_cmd[@]}" - "$CONFIG_FILE" "$CONFIG_KV_DELIM" >"$tmp" <<'PY'; then
import json
import sys

def describe(value):
    if isinstance(value, bool):
        return "bool", "true" if value else "false"
    if isinstance(value, (int, float)) and not isinstance(value, bool):
        return "number", str(value)
    if value is None:
        return "null", "null"
    if isinstance(value, str):
        return "string", value
    return "json", json.dumps(value, ensure_ascii=False)

def walk(prefix, node):
    if isinstance(node, dict):
        for key in sorted(node):
            new_prefix = f"{prefix}.{key}" if prefix else key
            yield from walk(new_prefix, node[key])
    elif isinstance(node, list):
        yield prefix, "json", json.dumps(node, ensure_ascii=False)
        for item in node:
            _, item_repr = describe(item)
            yield prefix, "array", item_repr
    else:
        value_type, value_repr = describe(node)
        yield prefix, value_type, value_repr

def main(path, delim):
    with open(path, "r", encoding="utf-8") as fh:
        data = json.load(fh)

    for key, value_type, value_repr in walk("", data):
        sys.stdout.write(f"{key}{delim}{value_type}{delim}{value_repr}\n")

if __name__ == "__main__":
    main(sys.argv[1], sys.argv[2])
PY
    local status=$?
    rm -f "$tmp"
    return $status
  fi

  if [ -n "${CONFIG_CACHE_FILE:-}" ]; then
    local cache_dir
    cache_dir=$(dirname "$CONFIG_CACHE_FILE")
    if [ -n "$cache_dir" ]; then
      mkdir -p "$cache_dir" 2>/dev/null || true
    fi

    chmod 600 "$tmp" 2>/dev/null || true
    if mv "$tmp" "$CONFIG_CACHE_FILE" 2>/dev/null; then
      cat "$CONFIG_CACHE_FILE"
      return 0
    fi
  fi

  cat "$tmp"
  rm -f "$tmp"
  return 0
}


config_load_cache() {
  if [ "$CONFIG_CACHE_LOADED" = "1" ]; then
    return 0
  fi

  CONFIG_CACHE_KEYS=()
  CONFIG_CACHE_TYPES=()
  CONFIG_CACHE_VALUES=()

  local entries
  if ! entries=$(config_collect_entries); then
    return 1
  fi

  if [ -n "$entries" ]; then
    local entry_key entry_type entry_raw
    while IFS="$CONFIG_KV_DELIM" read -r entry_key entry_type entry_raw; do
      [ -n "$entry_key" ] || continue
      if [ "$entry_type" = "array" ]; then
        config_cache_array_append "$entry_key" "$entry_raw"
        continue
      fi
      CONFIG_CACHE_KEYS+=("$entry_key")
      CONFIG_CACHE_TYPES+=("$entry_type")
      CONFIG_CACHE_VALUES+=("$entry_raw")
    done <<EOF
$entries
EOF
  fi

  CONFIG_CACHE_LOADED=1
  return 0
}

config_python() {
  if [ -n "$CONFIG_PYTHON_BIN" ]; then
    printf '%s\n' "$CONFIG_PYTHON_BIN"
    return 0
  fi

  local candidate
  for candidate in python3 python; do
    if command -v "$candidate" >/dev/null 2>&1; then
      CONFIG_PYTHON_BIN="$candidate"
      printf '%s\n' "$CONFIG_PYTHON_BIN"
      return 0
    fi
  done

  return 1
}

config_python_or_die() {
  local bin
  if ! bin=$(config_python); then
    die "python3 (or python) is required for JSON configuration"
  fi
  printf '%s\n' "$bin"
}

config_get_entry() {
  local key="${1:-}"
  [ -n "$key" ] || return 1

  if ! config_load_cache; then
    return 1
  fi

  local idx
  for idx in "${!CONFIG_CACHE_KEYS[@]}"; do
    if [ "${CONFIG_CACHE_KEYS[$idx]}" = "$key" ]; then
      printf '%s%s%s\n' "${CONFIG_CACHE_TYPES[$idx]}" "$CONFIG_KV_DELIM" "${CONFIG_CACHE_VALUES[$idx]}"
      return 0
    fi
  done

  return 1
}

config_get() {
  local key="$1"
  local entry
  entry=$(config_get_entry "$key") || return 1
  printf '%s\n' "${entry#*${CONFIG_KV_DELIM}}"
}

config_get_array() {
  local key="$1"
  [ -f "$CONFIG_FILE" ] || return 1
  [ -s "$CONFIG_FILE" ] || return 0

  if ! config_load_cache; then
    return 1
  fi

  local idx
  for idx in "${!CONFIG_CACHE_ARRAY_KEYS[@]}"; do
    if [ "${CONFIG_CACHE_ARRAY_KEYS[$idx]}" = "$key" ]; then
      local items="${CONFIG_CACHE_ARRAY_VALUES[$idx]}"
      if [ -n "$items" ]; then
        printf '%s\n' "$items"
      fi
      return 0
    fi
  done

  return 0
}

config_set() {
  if [ $# -ne 2 ]; then
    die "$(msg config_set_requires)"
  fi

  local key="$1"
  local value="$2"
  local python_bin
  python_bin=$(config_python_or_die)

  local status
  local -a python_cmd=("$python_bin" -S -B)

  "${python_cmd[@]}" - "$CONFIG_FILE" "$key" "$value" <<'PY'
import json
import os
import sys

def parse_value(raw):
    try:
        return json.loads(raw)
    except json.JSONDecodeError:
        return raw

def ensure_parent(path):
    directory = os.path.dirname(path)
    if directory and not os.path.exists(directory):
        os.makedirs(directory, exist_ok=True)

def main(path, dotted_key, raw_value):
    ensure_parent(path)
    if os.path.exists(path):
        with open(path, "r", encoding="utf-8") as fh:
            try:
                data = json.load(fh)
            except json.JSONDecodeError as exc:
                print(f"failed to parse config JSON: {exc}", file=sys.stderr)
                return 2
    else:
        data = {}

    parts = [part for part in dotted_key.split('.') if part]
    if not parts:
        print("config key cannot be empty", file=sys.stderr)
        return 2

    cursor = data
    for part in parts[:-1]:
        if part not in cursor or not isinstance(cursor[part], dict):
            cursor[part] = {}
        cursor = cursor[part]

    cursor[parts[-1]] = parse_value(raw_value)

    with open(path, "w", encoding="utf-8") as fh:
        json.dump(data, fh, ensure_ascii=False, indent=2)
        fh.write("\n")

    return 0

if __name__ == "__main__":
    sys.exit(main(sys.argv[1], sys.argv[2], sys.argv[3]))
PY
  status=$?

  if [ $status -ne 0 ]; then
    die "$(msg config_update_failed)"
  fi

  chmod 600 "$CONFIG_FILE" 2>/dev/null || true
  if [ -n "${CONFIG_CACHE_FILE:-}" ]; then
    rm -f "$CONFIG_CACHE_FILE"
  fi
  config_cache_reset
}

config_unset() {
  if [ $# -ne 1 ]; then
    die "$(msg config_unset_requires)"
  fi

  local key="$1"
  [ -f "$CONFIG_FILE" ] || die "$(msg config_file_missing "$CONFIG_FILE")"

  local python_bin
  python_bin=$(config_python_or_die)

  local status
  local -a python_cmd=("$python_bin" -S -B)

  "${python_cmd[@]}" - "$CONFIG_FILE" "$key" <<'PY'
import json
import os
import sys

def main(path, dotted_key):
    if not os.path.exists(path):
        print("config file not found", file=sys.stderr)
        return 3

    with open(path, "r", encoding="utf-8") as fh:
        try:
            data = json.load(fh)
        except json.JSONDecodeError as exc:
            print(f"failed to parse config JSON: {exc}", file=sys.stderr)
            return 2

    parts = [part for part in dotted_key.split('.') if part]
    if not parts:
        print("config key cannot be empty", file=sys.stderr)
        return 2

    cursor = data
    lineage = [cursor]
    for part in parts[:-1]:
        if part in cursor and isinstance(cursor[part], dict):
            cursor = cursor[part]
            lineage.append(cursor)
        else:
            return 1

    if parts[-1] not in cursor:
        return 1

    del cursor[parts[-1]]

    # Prune empty dicts from bottom up
    def prune(path_parts, containers):
        for idx in range(len(path_parts) - 1, -1, -1):
            key = path_parts[idx]
            container = containers[idx]
            if isinstance(container.get(key), dict) and not container[key]:
                del container[key]

    prune(parts[:-1], lineage)

    with open(path, "w", encoding="utf-8") as fh:
        json.dump(data, fh, ensure_ascii=False, indent=2)
        fh.write("\n")

    return 0

if __name__ == "__main__":
    sys.exit(main(sys.argv[1], sys.argv[2]))
PY
  status=$?

  case "$status" in
    0)
      chmod 600 "$CONFIG_FILE" 2>/dev/null || true
      if [ -n "${CONFIG_CACHE_FILE:-}" ]; then
        rm -f "$CONFIG_CACHE_FILE"
      fi
      config_cache_reset
      ;;
    1)
      die "$(msg config_key_not_set "$key")"
      ;;
    2)
      die "$(msg config_update_failed)"
      ;;
    3)
      die "$(msg config_file_missing "$CONFIG_FILE")"
      ;;
    *)
      die "$(msg config_update_failed)"
      ;;
  esac
}

config_iterate_file() {
  config_collect_entries
}

json_escape_string() {
  local input="$1"
  input="${input//\\/\\\\}"
  input="${input//\"/\\\"}"
  input="${input//$'\n'/\\n}"
  input="${input//$'\r'/\\r}"
  input="${input//$'\t'/\\t}"
  printf '%s' "$input"
}

json_array_from_list() {
  if [ $# -eq 0 ]; then
    printf '[]\n'
    return
  fi

  local json="["
  local first=1
  local item escaped
  for item in "$@"; do
    escaped=$(json_escape_string "$item")
    if [ $first -eq 0 ]; then
      json+=", "
    fi
    json+="\"$escaped\""
    first=0
  done
  json+=']'
  printf '%s\n' "$json"
}

init_settings() {
  DEFAULT_PROJECT_DIR="$DEFAULT_PROJECT_DIR_DEFAULT"
  LOG_SUBDIR="$LOG_SUBDIR_DEFAULT"
  AUTO_START_DEV="$AUTO_START_DEV_DEFAULT"
  ADD_INSTALL_DEPS="$ADD_INSTALL_DEPS_DEFAULT"
  ADD_COPY_ENV="$ADD_COPY_ENV_DEFAULT"
  COPY_ENV_FILES=("${COPY_ENV_FILES_DEFAULT[@]}")
  INSTALL_DEPS_COMMAND="$INSTALL_DEPS_COMMAND_DEFAULT"
  SERVE_DEV_COMMAND="$SERVE_DEV_COMMAND_DEFAULT"

  WORKTREE_PREFIX_DEFAULT="$(basename "$DEFAULT_PROJECT_DIR")."
  WORKTREE_PREFIX="${WT_WORKTREE_PREFIX:-$WORKTREE_PREFIX_DEFAULT}"

  local entry type raw_value

  if entry=$(config_get_entry "workingRepo.path" 2>/dev/null); then
    type="${entry%%${CONFIG_KV_DELIM}*}"
    raw_value="${entry#*${CONFIG_KV_DELIM}}"
    if [ "$type" = "string" ] && [ -n "$raw_value" ]; then
      DEFAULT_PROJECT_DIR="$raw_value"
      WORKTREE_PREFIX_DEFAULT="$(basename "$DEFAULT_PROJECT_DIR")."
      WORKTREE_PREFIX="${WT_WORKTREE_PREFIX:-$WORKTREE_PREFIX_DEFAULT}"
    fi
  fi

  if entry=$(config_get_entry "worktreeAdd.serveDev.loggingPath" 2>/dev/null); then
    type="${entry%%${CONFIG_KV_DELIM}*}"
    raw_value="${entry#*${CONFIG_KV_DELIM}}"
    if [ "$type" = "string" ] && [ -n "$raw_value" ]; then
      LOG_SUBDIR="$raw_value"
    fi
  fi

  if entry=$(config_get_entry "worktreeAdd.serveDev.enabled" 2>/dev/null); then
    raw_value="${entry#*${CONFIG_KV_DELIM}}"
    if bool=$(parse_bool "$raw_value" 2>/dev/null); then
      AUTO_START_DEV="$bool"
    fi
  fi

  if entry=$(config_get_entry "worktreeAdd.installDeps.enabled" 2>/dev/null); then
    raw_value="${entry#*${CONFIG_KV_DELIM}}"
    if bool=$(parse_bool "$raw_value" 2>/dev/null); then
      ADD_INSTALL_DEPS="$bool"
    fi
  fi

  if entry=$(config_get_entry "worktreeAdd.copyEnv.enabled" 2>/dev/null); then
    raw_value="${entry#*${CONFIG_KV_DELIM}}"
    if bool=$(parse_bool "$raw_value" 2>/dev/null); then
      ADD_COPY_ENV="$bool"
    fi
  fi

  local -a copy_files=()
  while IFS= read -r copy_item; do
    copy_files+=("$copy_item")
  done < <(config_get_array "worktreeAdd.copyEnv.files" 2>/dev/null || true)

  if [ ${#copy_files[@]} -gt 0 ]; then
    COPY_ENV_FILES=("${copy_files[@]}")
  fi

  if entry=$(config_get_entry "worktreeAdd.installDeps.command" 2>/dev/null); then
    type="${entry%%${CONFIG_KV_DELIM}*}"
    raw_value="${entry#*${CONFIG_KV_DELIM}}"
    if [ "$type" = "string" ] && [ -n "$raw_value" ]; then
      INSTALL_DEPS_COMMAND="$raw_value"
    fi
  fi

  if entry=$(config_get_entry "worktreeAdd.serveDev.command" 2>/dev/null); then
    type="${entry%%${CONFIG_KV_DELIM}*}"
    raw_value="${entry#*${CONFIG_KV_DELIM}}"
    if [ "$type" = "string" ] && [ -n "$raw_value" ]; then
      SERVE_DEV_COMMAND="$raw_value"
    fi
  fi

  if [ -n "${WT_LOG_SUBDIR:-}" ]; then
    LOG_SUBDIR="$WT_LOG_SUBDIR"
  fi

  if [ -n "${WT_ADD_AUTO_START_DEV:-}" ]; then
    if bool=$(parse_bool "$WT_ADD_AUTO_START_DEV" 2>/dev/null); then
      AUTO_START_DEV="$bool"
    fi
  fi

  if [ -n "${WT_ADD_INSTALL_DEPS:-}" ]; then
    if bool=$(parse_bool "$WT_ADD_INSTALL_DEPS" 2>/dev/null); then
      ADD_INSTALL_DEPS="$bool"
    fi
  fi

  if [ -n "${WT_ADD_COPY_ENV:-}" ]; then
    if bool=$(parse_bool "$WT_ADD_COPY_ENV" 2>/dev/null); then
      ADD_COPY_ENV="$bool"
    fi
  fi

  if [ -z "${WT_WORKTREE_PREFIX:-}" ]; then
    WORKTREE_PREFIX="${WT_WORKTREE_PREFIX:-$WORKTREE_PREFIX_DEFAULT}"
  fi

  init_language
}

info() {
  printf '%s\n' "$*" >&2
}

die() {
  printf 'wt: %s\n' "$*" >&2
  exit 1
}

usage() {
  local project_basename
  project_basename=$(basename "$DEFAULT_PROJECT_DIR")

  local project_dir_display="$DEFAULT_PROJECT_DIR"
  local project_dir_box_display="$DEFAULT_PROJECT_DIR"
  if [ -t 1 ] && command -v tput >/dev/null 2>&1; then
    local ansi_cyan ansi_bold ansi_reset
    ansi_cyan=$(tput setaf 6 2>/dev/null || true)
    ansi_bold=$(tput bold 2>/dev/null || true)
    ansi_reset=$(tput sgr0 2>/dev/null || true)
    if [ -n "$ansi_cyan$ansi_bold" ]; then
      project_dir_display="${ansi_bold}${ansi_cyan}${DEFAULT_PROJECT_DIR}${ansi_reset}"
    fi
  fi

  local dir_text_en="Project directory: ${project_dir_box_display}"
  local dir_text_zh="项目目录: ${project_dir_box_display}"

  local banner_width_en=${#dir_text_en}
  local banner_width_zh=${#dir_text_zh}

  if [ "$banner_width_en" -lt 40 ]; then
    banner_width_en=40
  fi
  if [ "$banner_width_zh" -lt 40 ]; then
    banner_width_zh=40
  fi

  local fill_en fill_zh
  fill_en=$(printf '%*s' "$banner_width_en" '')
  fill_en=${fill_en// /─}
  fill_zh=$(printf '%*s' "$banner_width_zh" '')
  fill_zh=${fill_zh// /─}

  local dir_top_en dir_mid_en dir_bottom_en dir_top_zh dir_mid_zh dir_bottom_zh
  dir_top_en="${fill_en}╮"
  dir_mid_en=$(printf '%-*s│' "$banner_width_en" "$dir_text_en")
  dir_bottom_en="${fill_en}╯"

  dir_top_zh="${fill_zh}╮"
  dir_mid_zh=$(printf '%-*s│' "$banner_width_zh" "$dir_text_zh")
  dir_bottom_zh="${fill_zh}╯"

  local dir_banner_en dir_banner_zh
  dir_banner_en=$(printf '%s\n%s\n%s' "$dir_top_en" "$dir_mid_en" "$dir_bottom_en")
  dir_banner_zh=$(printf '%s\n%s\n%s' "$dir_top_zh" "$dir_mid_zh" "$dir_bottom_zh")

  if [ "$project_dir_display" != "$project_dir_box_display" ]; then
    dir_banner_en=${dir_banner_en//Project directory: $project_dir_box_display/Project directory: $project_dir_display}
    dir_banner_zh=${dir_banner_zh//项目目录: $project_dir_box_display/项目目录: $project_dir_display}
  fi

  case "$LANGUAGE" in
    zh)
      cat <<USAGE_ZH

用法:
  wt <command> [参数]        执行 wt 子命令
  wt <worktree-name>         直接跳转到对应 worktree

核心命令:
  init               将当前仓库设为 wt 的默认项目
  add <name>         创建新 worktree，复制环境文件、安装依赖并启动 dev server（可通过 wt config 调整）
  main               跳转到主 worktree
  list               列出所有 worktree
  rm [name]          删除 worktree（省略 name 时使用当前目录）
  clean              清理数字 worktree（匹配前缀 + 数字）
  config             查看或更新 wt-cli 配置
  help               显示此帮助

${dir_banner_zh}

USAGE_ZH
      ;;
    *)
      cat <<USAGE_EN

Usage:
  wt <command> [args]        Run a wt subcommand
  wt <worktree-name>         Jump straight to a worktree

Core commands:
  init               Remember this repository as wt's default project
  add <name>         Create a new worktree, copy env files, install deps, start dev server (tunable via wt config)
  main               Jump to the main worktree
  list               List all worktrees
  rm [name]          Remove a worktree (current directory if name omitted)
  clean              Remove numeric worktrees (matching prefix + digits)
  config             Inspect or update wt-cli configuration
  help               Show this guide

${dir_banner_en}

USAGE_EN
      ;;
  esac
}

usage_exit() {
  local status="${1:-0}"
  usage
  exit "$status"
}

PROJECT_DIR=""
PROJECT_DIR_ABS=""
PROJECT_PARENT=""

resolve_project() {
  command -v git >/dev/null 2>&1 || die "$(msg git_required)"

  if [ -z "$PROJECT_DIR" ]; then
    PROJECT_DIR="${WT_PROJECT_DIR:-$DEFAULT_PROJECT_DIR}"
  fi

  PROJECT_DIR_ABS=$(cd "$PROJECT_DIR" 2>/dev/null && pwd) || die "$(msg project_not_found "$PROJECT_DIR")"
  PROJECT_PARENT=$(dirname "$PROJECT_DIR_ABS")
}

worktree_path_for() {
  local name="$1"
  printf '%s/%s%s\n' "$PROJECT_PARENT" "$WORKTREE_PREFIX" "$name"
}

branch_for() {
  local name="$1"
  printf '%s%s\n' "$BRANCH_PREFIX" "$name"
}

port_from_name() {
  local name="$1"
  if [[ "$name" =~ ^[0-9]+$ ]]; then
    if [ "$name" -ge 1024 ] && [ "$name" -le 65535 ]; then
      printf '%s\n' "$name"
      return 0
    fi
  fi
  printf ''
}

git_project() {
  git -C "$PROJECT_DIR_ABS" "$@"
}

copy_env_file() {
  local file_name="$1"
  local target_dir="$2"
  if [ -f "$PROJECT_DIR_ABS/$file_name" ]; then
    cp "$PROJECT_DIR_ABS/$file_name" "$target_dir/"
    info "$(msg copy_env_file "$file_name")"
  fi
}

command_exists_for_line() {
  local line="$1"
  if [ -z "$line" ]; then
    return 1
  fi

  local -a tokens
  IFS=' ' read -r -a tokens <<<"$line"
  if [ ${#tokens[@]} -eq 0 ]; then
    return 1
  fi

  local token
  for token in "${tokens[@]}"; do
    if [[ "$token" == *=* ]]; then
      continue
    fi
    if command -v "$token" >/dev/null 2>&1; then
      return 0
    fi
    return 1
  done

  return 1
}

run_install_command() {
  local worktree_path="${1:?worktree path is required}"
  local command_line="${2:-}"

  if [ -z "$command_line" ]; then
    info "$(msg install_skipped_no_command)"
    return
  fi

  if ! command_exists_for_line "$command_line"; then
    info "$(msg command_not_found "$command_line")"
    return
  fi

  info "$(msg installing_dependencies "$command_line")"
  (
    cd "$worktree_path"
    sh -c "$command_line" >&2
  )
}

command_slug_from_line() {
  local line="$1"
  if [ -z "$line" ]; then
    printf 'dev'
    return
  fi

  local slug
  slug=$(printf '%s' "$line" | tr '[:space:]/\\' '____')
  slug=${slug//[^A-Za-z0-9._-]/_}
  slug=${slug#_}
  slug=${slug%%_}
  if [ -z "$slug" ]; then
    slug='dev'
  fi
  slug=${slug:0:40}
  printf '%s' "$slug"
}

infer_install_command() {
  local worktree_path="${1:?worktree path is required}"

  if [ -f "$worktree_path/pnpm-lock.yaml" ]; then
    printf 'pnpm install --frozen-lockfile\n'
    return 0
  fi

  if [ -f "$worktree_path/yarn.lock" ]; then
    printf 'yarn install --frozen-lockfile\n'
    return 0
  fi

  if [ -f "$worktree_path/bun.lockb" ]; then
    printf 'bun install\n'
    return 0
  fi

  if [ -f "$worktree_path/package.json" ]; then
    if [ -f "$worktree_path/package-lock.json" ] || [ -f "$worktree_path/npm-shrinkwrap.json" ]; then
      printf '%s ci\n' "$NPM_BIN"
      return 0
    fi
    printf '%s install\n' "$NPM_BIN"
    return 0
  fi

  if [ -f "$worktree_path/poetry.lock" ]; then
    printf 'poetry install\n'
    return 0
  fi

  if [ -f "$worktree_path/Pipfile" ]; then
    printf 'pipenv install\n'
    return 0
  fi

  if [ -f "$worktree_path/requirements.txt" ]; then
    printf 'pip install -r requirements.txt\n'
    return 0
  fi

  if [ -f "$worktree_path/pyproject.toml" ]; then
    printf 'pip install -e .\n'
    return 0
  fi

  return 1
}

infer_serve_command() {
  local worktree_path="${1:?worktree path is required}"

  if [ -f "$worktree_path/pnpm-lock.yaml" ] && has_package_json_script "$worktree_path" "dev"; then
    printf 'pnpm dev\n'
    return 0
  fi

  if [ -f "$worktree_path/yarn.lock" ] && has_package_json_script "$worktree_path" "dev"; then
    printf 'yarn dev\n'
    return 0
  fi

  if [ -f "$worktree_path/bun.lockb" ] && has_package_json_script "$worktree_path" "dev"; then
    printf 'bun dev\n'
    return 0
  fi

  if [ -f "$worktree_path/package.json" ]; then
    if has_package_json_script "$worktree_path" "dev"; then
      printf '%s run dev\n' "$NPM_BIN"
      return 0
    fi
    if has_package_json_script "$worktree_path" "start"; then
      printf '%s run start\n' "$NPM_BIN"
      return 0
    fi
  fi

  if [ -f "$worktree_path/manage.py" ]; then
    printf 'python manage.py runserver\n'
    return 0
  fi

  if [ -f "$worktree_path/pyproject.toml" ] && [ -f "$worktree_path/app.py" ]; then
    printf 'python app.py\n'
    return 0
  fi

  if [ -f "$worktree_path/app.py" ]; then
    printf 'python app.py\n'
    return 0
  fi

  return 1
}

has_package_json_script() {
  local project_dir="${1:?project directory is required}"
  local script_name="${2:?script name is required}"
  local package_json="$project_dir/package.json"

  [ -f "$package_json" ] || return 1

  if command -v node >/dev/null 2>&1; then
    if node - "$package_json" "$script_name" >/dev/null 2>&1 <<'NODE'
const fs = require('fs');
const [pkgPath, scriptName] = process.argv.slice(2);
try {
  const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8')) || {};
  if (pkg.scripts && pkg.scripts[scriptName]) {
    process.exit(0);
  }
} catch (err) {}
process.exit(1);
NODE
    then
      return 0
    fi
  fi

  local python=""
  for candidate in python3 python; do
    if command -v "$candidate" >/dev/null 2>&1; then
      python="$candidate"
      break
    fi
  done

  if [ -n "$python" ]; then
    if "$python" - "$package_json" "$script_name" >/dev/null 2>&1 <<'PY'
import json
import sys

pkg_path = sys.argv[1]
script_name = sys.argv[2]

try:
    with open(pkg_path, 'r', encoding='utf-8') as f:
        data = json.load(f)
    scripts = data.get('scripts') or {}
    if scripts.get(script_name):
        sys.exit(0)
except Exception:
    pass

sys.exit(1)
PY
    then
      return 0
    fi
  fi

  return 1
}

start_dev_server() {
  local worktree_path="${1:?worktree path is required}"
  local command_line="${2:-}"
  local port="${3:-}"

  if [ -z "$command_line" ]; then
    info "$(msg dev_skipped_no_command)"
    return
  fi

  if ! command_exists_for_line "$command_line"; then
    info "$(msg command_not_found "$command_line")"
    return
  fi

  mkdir -p "$worktree_path/$LOG_SUBDIR"
  local slug
  slug=$(command_slug_from_line "$command_line")

  local log_file
  if [ -n "$port" ]; then
    log_file="$worktree_path/$LOG_SUBDIR/${slug}-${port}.log"
  else
    log_file="$worktree_path/$LOG_SUBDIR/${slug}.log"
  fi
  local pid_file="${log_file}.pid"

  info "$(msg dev_command "$command_line")"
  if [ -n "$port" ]; then
    info "$(msg start_dev_port "$port")"
  else
    info "$(msg start_dev_generic)"
  fi

  (
    cd "$worktree_path"
    if [ -n "$port" ]; then
      nohup env PORT="$port" sh -c "$command_line" > "$log_file" 2>&1 &
    else
      nohup sh -c "$command_line" > "$log_file" 2>&1 &
    fi
    printf '%s\n' "$!" > "$pid_file"
  )

  local pid=""
  if [ -f "$pid_file" ]; then
    pid=$(cat "$pid_file" 2>/dev/null || true)
  fi

  sleep 1

  if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
    if [ -n "$port" ]; then
      info "$(msg dev_started_port "$port")"
    else
      info "$(msg dev_started_default)"
    fi
  else
    local pid_display="${pid:-unknown}"
    info "$(msg dev_failed "$pid_display" "$log_file")"
  fi

  info "$(msg dev_log_hint "$log_file")"
}

maybe_warn_shell_integration() {
  local target_path="${1:-}"

  if [ -n "${WT_SHELL_WRAPPED:-}" ]; then
    return
  fi

  if [ "${WT_SUPPRESS_AUTO_CD_HINT:-0}" = "1" ]; then
    return
  fi

  if [ ! -t 1 ]; then
    return
  fi

  if [ -z "$target_path" ] || [ ! -d "$target_path" ]; then
    return
  fi

  if [ "${WT_AUTO_CD_HINT_SHOWN:-0}" = "1" ]; then
    return
  fi

  WT_AUTO_CD_HINT_SHOWN=1

  local shell_name
  shell_name="${SHELL##*/}"
  if [ -z "$shell_name" ]; then
    shell_name="zsh"
  fi

  local hook_cmd="" rc_hint="reload your shell configuration" rc_file="" hook_present=0
  local hook_marker="# wt shell integration: auto-cd after wt add/path/main/remove/clean"

  case "$shell_name" in
    zsh)
      hook_cmd='wt shell-hook zsh >> ~/.zshrc'
      rc_hint='source ~/.zshrc'
      rc_file="$HOME/.zshrc"
      ;;
    bash)
      hook_cmd='wt shell-hook bash >> ~/.bashrc'
      rc_hint='source ~/.bashrc'
      rc_file="$HOME/.bashrc"
      ;;
    *)
      hook_cmd='wt shell-hook zsh >> ~/.zshrc'
      ;;
  esac

  if [ -n "$rc_file" ] && [ -f "$rc_file" ] && grep -Fq "$hook_marker" "$rc_file"; then
    hook_present=1
  fi

  if [ "$hook_present" -eq 1 ]; then
    info "$(msg auto_cd_pending "$rc_hint")"
    info "$(msg auto_cd_retry)"
    return
  fi

  info "$(msg auto_cd_disabled "$hook_cmd")"
  if [ "$rc_hint" = "reload your shell configuration" ]; then
    info "$(msg auto_cd_reload)"
  else
    info "$(msg auto_cd_execute "$rc_hint")"
  fi
}

cmd_list() {
  [ $# -eq 0 ] || die "$(msg list_no_args)"
  git_project worktree list
}

cmd_main() {
  [ $# -eq 0 ] || die "$(msg main_no_args)"
  maybe_warn_shell_integration "$PROJECT_DIR_ABS"
  printf '%s\n' "$PROJECT_DIR_ABS"
}

cmd_path() {
  if [ $# -ne 1 ]; then
    die "$(msg path_requires_name)"
  fi
  local name="$1"
  local target_path
  target_path=$(worktree_path_for "$name")
  if [ ! -d "$target_path" ]; then
    die "$(msg worktree_not_found "$name")"
  fi
  maybe_warn_shell_integration "$target_path"
  printf '%s\n' "$target_path"
}

cmd_add() {
  local name="$1"
  shift || true

  [ -n "$name" ] || die "$(msg add_requires_name)"

  local run_install="$ADD_INSTALL_DEPS"
  local run_dev="$AUTO_START_DEV"
  local copy_env="$ADD_COPY_ENV"
  local branch=""
  local numeric_name=""
  local effective_port=""

  if [[ "$name" =~ ^[0-9]+$ ]]; then
    numeric_name="$name"
    if [ "$numeric_name" -ge 1 ] && [ "$numeric_name" -lt 1024 ]; then
      info "$(msg reserved_port "$numeric_name")"
    elif [ "$numeric_name" -gt 65535 ]; then
      info "$(msg port_out_of_range "$numeric_name")"
    fi
  fi

  while [ $# -gt 0 ]; do
    case "$1" in
      -h|--help|help)
        usage
        exit 0
        ;;
      --)
        shift
        break
        ;;
      -*)
        die "$(msg add_unknown_option "$1")"
        ;;
      *)
        die "$(msg unexpected_extra_argument "$1")"
        ;;
    esac
    shift || true
  done

  if [ $# -gt 0 ]; then
    die "$(msg unexpected_extra_argument "$1")"
  fi

  if [ "$run_dev" -eq 1 ]; then
    effective_port=$(port_from_name "$name")

    if [ -z "$effective_port" ] && [ -n "$numeric_name" ]; then
      if [ "$numeric_name" -lt 1024 ]; then
        info "$(msg fallback_default_port)"
      elif [ "$numeric_name" -gt 65535 ]; then
        info "$(msg fallback_default_port)"
      fi
    fi
  fi

  local worktree_path
  worktree_path=$(worktree_path_for "$name")

  if [ -e "$worktree_path" ]; then
    die "$(msg worktree_exists "$worktree_path")"
  fi

  if [ -z "$branch" ]; then
    branch=$(branch_for "$name")
  fi

  info "$(msg creating_worktree "$worktree_path" "$branch")"
  git_project worktree add -b "$branch" "$worktree_path" >&2
  info "$(msg worktree_created)"

  if [ "$copy_env" -eq 1 ]; then
    if [ ${#COPY_ENV_FILES[@]} -gt 0 ]; then
      local env_file
      for env_file in "${COPY_ENV_FILES[@]}"; do
        [ -n "$env_file" ] || continue
        copy_env_file "$env_file" "$worktree_path"
      done
    fi
  fi

  local install_command="$INSTALL_DEPS_COMMAND"
  local serve_command="$SERVE_DEV_COMMAND"

  if [ "$run_install" -eq 1 ] && [ -z "$install_command" ]; then
    if install_command=$(infer_install_command "$worktree_path"); then
      info "$(msg install_detected "$install_command")"
    fi
  fi

  if [ "$run_dev" -eq 1 ] && [ -z "$serve_command" ]; then
    if serve_command=$(infer_serve_command "$worktree_path"); then
      info "$(msg serve_detected "$serve_command")"
    fi
  fi

  if [ "$run_install" -eq 1 ]; then
    run_install_command "$worktree_path" "$install_command"
  fi

  if [ "$run_dev" -eq 1 ]; then
    start_dev_server "$worktree_path" "$serve_command" "$effective_port"
  else
    info "$(msg dev_skipped_config)"
  fi

  info "$(msg worktree_ready "$worktree_path")"
  maybe_warn_shell_integration "$worktree_path"
  printf '%s\n' "$worktree_path"
}

config_print_effective() {
  printf 'language=%s\n' "$LANGUAGE"
  printf 'workingRepo.path=%s\n' "$DEFAULT_PROJECT_DIR"

  local branch_value
  if branch_value=$(config_get "workingRepo.branch" 2>/dev/null); then
    if [ -n "$branch_value" ]; then
      printf 'workingRepo.branch=%s\n' "$branch_value"
    fi
  fi

  if [ "$ADD_COPY_ENV" -eq 1 ]; then
    printf 'worktreeAdd.copyEnv.enabled=true\n'
  else
    printf 'worktreeAdd.copyEnv.enabled=false\n'
  fi
  printf 'worktreeAdd.copyEnv.files=%s\n' "$(json_array_from_list "${COPY_ENV_FILES[@]}")"

  if [ "$ADD_INSTALL_DEPS" -eq 1 ]; then
    printf 'worktreeAdd.installDeps.enabled=true\n'
  else
    printf 'worktreeAdd.installDeps.enabled=false\n'
  fi
  printf 'worktreeAdd.installDeps.command=%s\n' "$INSTALL_DEPS_COMMAND"

  if [ "$AUTO_START_DEV" -eq 1 ]; then
    printf 'worktreeAdd.serveDev.enabled=true\n'
  else
    printf 'worktreeAdd.serveDev.enabled=false\n'
  fi
  printf 'worktreeAdd.serveDev.command=%s\n' "$SERVE_DEV_COMMAND"
  printf 'worktreeAdd.serveDev.loggingPath=%s\n' "$LOG_SUBDIR"

  while IFS="$CONFIG_KV_DELIM" read -r key type raw; do
    case "$key" in
      language|\
      workingRepo.path|\
      workingRepo.branch|\
      worktreeAdd.copyEnv.enabled|\
      worktreeAdd.copyEnv.files|\
      worktreeAdd.installDeps.enabled|\
      worktreeAdd.installDeps.command|\
      worktreeAdd.serveDev.enabled|\
      worktreeAdd.serveDev.command|\
      worktreeAdd.serveDev.loggingPath)
        continue
        ;;
    esac
    local value="$raw"
    printf '%s=%s\n' "$key" "$value"
  done < <(config_iterate_file)
}

config_usage() {
  case "$LANGUAGE" in
    zh)
      cat <<'CONFIG_USAGE_ZH'
wt config - 查看或更新 wt-cli 配置

子命令:
  wt config list                 显示生效配置（包含默认值）
  wt config get <key>            输出指定配置项（若缺失则报错）
  wt config set <key> <value>    将配置写入 ~/.wt-cli
  wt config unset <key>          从 ~/.wt-cli 移除配置

快捷方式:
  wt config <key>                等同于 get
  wt config <key> <value>        等同于 set

支持的键:
  language                        CLI 显示语言（en|zh，默认 en）
  workingRepo.path                默认维护的仓库根目录（由 wt init 设置）
  workingRepo.branch              新 worktree 的默认分支（可选）
  worktreeAdd.copyEnv.enabled     是否在 wt add 时复制环境文件
  worktreeAdd.copyEnv.files       被复制的环境文件列表（JSON 数组）
  worktreeAdd.installDeps.enabled 是否在 wt add 时安装依赖
  worktreeAdd.installDeps.command 安装依赖使用的命令（留空则自动推断）
  worktreeAdd.serveDev.enabled    是否在 wt add 后启动开发服务
  worktreeAdd.serveDev.command    启动开发服务的命令（留空则自动推断）
  worktreeAdd.serveDev.loggingPath Dev 服务日志所在子目录（默认: tmp）

说明:
  单次执行可通过环境变量（例如 WT_PROJECT_DIR）覆盖配置。
  布尔值接受 true/false/1/0/yes/no/on/off。
CONFIG_USAGE_ZH
      ;;
    *)
      cat <<'CONFIG_USAGE_EN'
wt config - Inspect or update wt-cli configuration

Subcommands:
  wt config list                 Show effective configuration (includes defaults)
  wt config get <key>            Print a single value (fails if missing)
  wt config set <key> <value>    Persist value in ~/.wt-cli
  wt config unset <key>          Remove key from ~/.wt-cli

Shortcuts:
  wt config <key>                Shortcut for get
  wt config <key> <value>        Shortcut for set

Supported keys:
  language                        CLI language (en or zh; default: en)
  workingRepo.path                Root directory of the tracked repository (set by wt init)
  workingRepo.branch              Default branch for new worktrees (optional)
  worktreeAdd.copyEnv.enabled     Whether wt add copies environment files
  worktreeAdd.copyEnv.files       Environment files to copy (JSON array)
  worktreeAdd.installDeps.enabled Whether wt add installs dependencies
  worktreeAdd.installDeps.command Command used to install dependencies (empty = auto-detect)
  worktreeAdd.serveDev.enabled    Whether wt add starts the dev service
  worktreeAdd.serveDev.command    Command used to start the dev service (empty = auto-detect)
  worktreeAdd.serveDev.loggingPath Subdirectory for dev logs (default: tmp)

Notes:
  Environment variables (like WT_PROJECT_DIR) override config for a single invocation.
  Boolean values accept true/false/1/0/yes/no/on/off.
CONFIG_USAGE_EN
      ;;
  esac
}

cmd_config() {
  if [ $# -eq 0 ]; then
    config_usage
    return
  fi

  case "$1" in
    list|--list)
      if [ $# -ne 1 ]; then
        die "$(msg config_list_no_args)"
      fi
      init_settings
      config_print_effective
      ;;
    get|--get)
      shift || die "$(msg config_get_requires_key)"
      if [ $# -ne 1 ]; then
        die "$(msg config_get_requires_exactly_one)"
      fi
      local key="$1"
      local value
      if value=$(config_get "$key" 2>/dev/null); then
        printf '%s\n' "$value"
      else
        die "$(msg config_key_not_found "$key")"
      fi
      ;;
    set|--set)
      shift || die "$(msg config_set_requires)"
      if [ $# -ne 2 ]; then
        die "$(msg config_set_requires)"
      fi
      local key="$1"
      shift
      local value="$1"
      if [ "$key" = "language" ]; then
        if normalized=$(normalize_language "$value" 2>/dev/null); then
          value=$(language_code_to_config_value "$normalized")
        else
          die "$(msg invalid_language "$value")"
        fi
      fi
      config_set "$key" "$value"
      ;;
    unset|--unset)
      shift || die "$(msg config_unset_requires_key)"
      if [ $# -ne 1 ]; then
        die "$(msg config_unset_requires_exactly_one)"
      fi
      local key="$1"
      config_unset "$key"
      ;;
    -h|--help|help)
      config_usage
      ;;
    --*)
      die "$(msg config_unknown_option "$1")"
      ;;
    *)
      if [ $# -eq 1 ]; then
        local key="$1"
        local value
        if value=$(config_get "$key" 2>/dev/null); then
          printf '%s\n' "$value"
        else
          die "$(msg config_key_not_found "$key")"
        fi
      elif [ $# -eq 2 ]; then
        local key="$1"
        local value="$2"
        if [ "$key" = "language" ]; then
          if normalized=$(normalize_language "$value" 2>/dev/null); then
            value=$(language_code_to_config_value "$normalized")
          else
            die "$(msg invalid_language "$value")"
          fi
        fi
        config_set "$key" "$value"
      else
        die "$(msg config_expect_key_or_value)"
      fi
      ;;
  esac
}

cmd_shell_hook() {
  if [ $# -eq 0 ]; then
    die "$(msg shell_hook_requires_shell)"
  fi

  case "$1" in
    -h|--help|help)
      case "$LANGUAGE" in
        zh)
          cat <<'HOOK_USAGE_ZH'
wt shell-hook 用法:
  wt shell-hook zsh
  wt shell-hook bash

将输出通过 eval/source 加载以安装包装函数，例如：
  eval "$(wt shell-hook zsh)"
HOOK_USAGE_ZH
          ;;
        *)
          cat <<'HOOK_USAGE_EN'
wt shell-hook usage:
  wt shell-hook zsh
  wt shell-hook bash

Pipe the output into eval/source to install the wrapper, e.g.
  eval "$(wt shell-hook zsh)"
HOOK_USAGE_EN
          ;;
      esac
      return
      ;;
  esac

  local shell="$1"
  case "$shell" in
    zsh|bash)
      cat <<'WT_HOOK'
# wt shell integration: auto-cd after wt add/path/main/remove/clean
wt() {
  local __wt_out __wt_status __wt_cmd __wt_should_cd=0
  __wt_out="$(WT_SHELL_WRAPPED=1 command wt "$@")"
  __wt_status=$?

  if [ $__wt_status -ne 0 ]; then
    if [ -n "$__wt_out" ]; then
      printf '%s\n' "$__wt_out"
    fi
    return $__wt_status
  fi

  if [ $# -eq 0 ]; then
    __wt_cmd="list"
  else
    __wt_cmd="$1"
  fi

  case "$__wt_cmd" in
    add|main|path)
      __wt_should_cd=1
      ;;
    remove|rm|clean)
      __wt_should_cd=1
      ;;
    config|list|help|-h|--help|--version|version)
      __wt_should_cd=0
      ;;
    -*)
      __wt_should_cd=0
      ;;
    *)
      __wt_should_cd=1
      ;;
  esac

  if [ $__wt_should_cd -eq 1 ] && [ -n "$__wt_out" ] && [ -d "$__wt_out" ]; then
    cd "$__wt_out" || return $?
    return 0
  fi

  if [ -n "$__wt_out" ]; then
    printf '%s\n' "$__wt_out"
  fi
}
# wt shell integration: end
WT_HOOK
      ;;
    *)
      die "$(msg shell_hook_unsupported_shell "$shell")"
      ;;
  esac
}

cmd_init() {
  local branch=""
  while [ $# -gt 0 ]; do
    case "$1" in
      --branch|branch)
        shift || die "$(msg branch_requires_value)"
        branch="$1"
        ;;
      -h|--help|help)
        case "$LANGUAGE" in
          zh)
            cat <<'INIT_USAGE_ZH'
wt init 用法:
  wt init [branch <name>]

请在 franxx.store 仓库根目录运行，以将设置写入 ~/.wt-cli：
- 设置 workingRepo.path 为仓库根目录。
- 提供 branch <name> 时设置 workingRepo.branch（默认使用当前分支）。
INIT_USAGE_ZH
            ;;
          *)
            cat <<'INIT_USAGE_EN'
wt init usage:
  wt init [branch <name>]

Run inside the franxx.store repository to capture settings into ~/.wt-cli.
- Sets workingRepo.path to the repo root.
- Optionally sets workingRepo.branch when branch <name> is provided (defaults to current branch).
INIT_USAGE_EN
            ;;
        esac
        return
        ;;
      --)
        shift
        break
        ;;
      -*)
        die "$(msg init_unknown_option "$1")"
        ;;
      *)
        die "$(msg init_no_positional)"
        ;;
    esac
    shift || true
  done

  local repo_root
  repo_root=$(git rev-parse --show-toplevel 2>/dev/null) || die "$(msg init_run_inside_git)"
  config_set "workingRepo.path" "$repo_root"
  info "$(msg init_set_project "$repo_root")"

  if [ -z "$branch" ]; then
    branch=$(git symbolic-ref --quiet --short HEAD 2>/dev/null || true)
  fi

  if [ -n "$branch" ]; then
    config_set "workingRepo.branch" "$branch"
    info "$(msg init_set_branch "$branch")"
  fi

  info "$(msg init_done)"
}

cmd_remove() {
  local name=""
  local assume_yes=0

  while [ $# -gt 0 ]; do
    case "$1" in
      -y|--yes|yes)
        assume_yes=1
        ;;
      -h|--help|help)
        usage
        exit 0
        ;;
      -*)
        die "$(msg remove_unknown_option "$1")"
        ;;
      *)
        if [ -n "$name" ]; then
          die "$(msg remove_accepts_at_most_one)"
        fi
        name="$1"
        ;;
    esac
    shift || true
  done

  local target_path=""
  local removing_current=0
  local current_abs
  current_abs=$(pwd -P)

  if [ -n "$name" ]; then
    target_path=$(worktree_path_for "$name")
    [ -d "$target_path" ] || die "$(msg worktree_not_found "$name")"
    if [ "$current_abs" = "$target_path" ]; then
      removing_current=1
    fi
  else
    if [ "$current_abs" = "$PROJECT_DIR_ABS" ]; then
      die "$(msg cannot_remove_main)"
    fi
    local current_base
    current_base=$(basename "$current_abs")
    if [[ "$current_base" != "$WORKTREE_PREFIX"* ]]; then
      die "$(msg specify_worktree_or_inside)"
    fi
    name="${current_base#$WORKTREE_PREFIX}"
    target_path="$current_abs"
    removing_current=1

    if [ "$assume_yes" -eq 0 ]; then
      printf '%s ' "$(msg remove_confirm_prompt "$name")" >&2
      read -r reply
      if [ -n "$reply" ] && [[ ! "$reply" =~ ^[Yy]$ ]]; then
        info "$(msg aborted)"
        return 1
      fi
    fi
  fi

  info "$(msg removing_worktree "$target_path")"
  git_project worktree remove "$target_path" --force >&2 || die "$(msg remove_failed)"

  local branch
  branch=$(branch_for "$name")
  if git_project show-ref --verify --quiet "refs/heads/$branch"; then
    git_project branch -D "$branch" >&2 || true
    info "$(msg removed_branch "$branch")"
  fi

  info "$(msg worktree_removed "$name")"

  if [ "$removing_current" -eq 1 ]; then
    info "$(msg current_worktree_removed)"
    maybe_warn_shell_integration "$PROJECT_DIR_ABS"
    printf '%s\n' "$PROJECT_DIR_ABS"
  fi
}

cmd_clean() {
  [ $# -eq 0 ] || die "$(msg clean_no_args)"
  local removed=0
  local current_abs
  current_abs=$(pwd -P)
  local current_removed=0

  while IFS= read -r worktree_path; do
    local base
    base=$(basename "$worktree_path")
    if [[ "$base" == "$WORKTREE_PREFIX"* ]]; then
      local suffix="${base#$WORKTREE_PREFIX}"
      if [[ "$suffix" =~ ^[0-9]+$ ]]; then
        info "$(msg cleaning_worktree "$suffix")"
        git_project worktree remove "$worktree_path" --force >&2 || true
        local branch_name
        branch_name=$(branch_for "$suffix")
        git_project branch -D "$branch_name" >/dev/null 2>&1 || true
        removed=$((removed + 1))
        if [ "$current_abs" = "$worktree_path" ]; then
          current_removed=1
        fi
      fi
    fi
  done < <(git_project worktree list --porcelain | awk '/^worktree / {print $2}')

  if [ "$removed" -gt 0 ]; then
    info "$(msg cleaned_count "$removed")"
  else
    info "$(msg cleaned_none)"
  fi

  if [ "$current_removed" -eq 1 ]; then
    info "$(msg clean_switch_back)"
    maybe_warn_shell_integration "$PROJECT_DIR_ABS"
    printf '%s\n' "$PROJECT_DIR_ABS"
  fi
}

main() {
  init_settings

  local command=""
  while [ $# -gt 0 ]; do
    case "$1" in
      --)
        shift
        break
        ;;
      -*)
        usage_exit 1
        ;;
      *)
        break
        ;;
    esac
    shift || true
  done

  if [ $# -eq 0 ]; then
    command="help"
  else
    command="$1"
    shift || true
  fi

  case "$command" in
    config)
      cmd_config "$@"
      return
      ;;
    shell-hook)
      cmd_shell_hook "$@"
      return
      ;;
    init)
      cmd_init "$@"
      return
      ;;
    help)
      usage
      return
      ;;
    version)
      printf '%s\n' "$VERSION"
      return
      ;;
  esac

  resolve_project

  case "$command" in
    list)
      cmd_list "$@"
      ;;
    add)
      [ $# -ge 1 ] || die "$(msg add_requires_name)"
      cmd_add "$@"
      ;;
    rm|remove)
      cmd_remove "$@"
      ;;
    clean)
      cmd_clean "$@"
      ;;
    main)
      cmd_main "$@"
      ;;
    path)
      cmd_path "$@"
      ;;
    *)
      cmd_path "$command" "$@"
      ;;
  esac
}

main "$@"
